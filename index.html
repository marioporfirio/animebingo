<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anime Bingo</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1e293b; }
        ::-webkit-scrollbar-thumb { background: #4f46e5; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #4338ca; }
        .hidden { display: none !important; }
        .modal-overlay {
            position: fixed; inset: 0; background-color: rgba(15, 23, 42, 0.8); 
            backdrop-filter: blur(4px); display: flex; align-items: center; justify-content: center;
            padding: 1rem; z-index: 110; overflow-y: auto;
        }
        .modal-content {
            background-color: #1e293b; padding: 1.5rem 2rem; border-radius: 0.75rem; 
            box-shadow: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1); 
            text-align: center; max-width: 28rem; width: 100%; margin: auto;
        }
        .search-results-modal-content { 
            background-color: #1e293b; padding: 1.5rem; border-radius: 0.75rem; 
            box-shadow: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1); 
            width: 90%; max-width: 48rem; max-height: 80vh; overflow-y: auto;
        }
        .search-result-item {
            display: flex; gap: 0.75rem; padding: 0.75rem;
            background-color: #334155; border-radius: 0.5rem; margin-bottom: 0.5rem;
            transition: background-color 0.2s;
        }
        .search-result-item:hover { background-color: #475569; }
        .search-result-item img { width: 50px; height: 75px; object-fit: cover; border-radius: 0.25rem; flex-shrink: 0; }
        .search-result-info { text-align: left; flex-grow: 1; }
        .search-result-actions { display: flex; align-items: center; }

        .indication-card {
            display: flex; align-items: center; gap: 0.75rem; 
            padding: 0.75rem; background-color: #334155; 
            border-radius: 0.5rem; border: 1px solid #475569; 
        }
        .indication-card img { width: 60px; height: 90px; object-fit: cover; border-radius: 0.25rem; }
        .indication-card-info { text-align: left; flex-grow: 1; }
        .tab-button-active { border-color: #6366f1 !important; color: #6366f1 !important; } 
        .game-list-item {
            display: flex; justify-content: space-between; align-items: center;
            padding: 0.75rem 1rem; background-color: #334155; border-radius: 0.5rem;
            margin-bottom: 0.5rem; cursor: pointer; transition: background-color 0.2s;
        }
        .game-list-item:hover { background-color: #475569; }
        .game-list-item span { flex-grow: 1; }
        .score-badge {
            background-color: #facc15; color: #1e293b; 
            padding: 0.125rem 0.5rem; border-radius: 0.25rem; font-weight: bold; font-size: 0.9em;
        }
        .genre-legend-item { 
            display: flex; flex-direction: column; align-items: center; justify-content: flex-start; 
            aspect-ratio: 1 / 1; padding: 0.5rem; box-sizing: border-box; overflow: hidden; position: relative; 
            cursor: pointer; 
        }
        .genre-legend-item:hover {
            background-color: #475569;
        }
        .genre-legend-item.selected-for-club { /* Estilo para g√™nero selecionado no modo clube */
            outline: 3px solid #818cf8;
            outline-offset: -3px;
            box-shadow: 0 0 10px #818cf8;
        }
        .genre-legend-item .genre-image-wrapper { 
            width: 100%; flex-grow: 1; display: flex; align-items: center; justify-content: center;
            overflow: hidden; margin-bottom: 0.375rem; 
        }
        .genre-legend-item img { 
            max-width: 85%; max-height: 85%; object-fit: contain; border-radius: 0.375rem; 
        }
        .genre-legend-item p { 
            font-size: 1.1rem; line-height: 1.2; font-weight: 600; color: #c7d2fe; 
            text-align: center; width: 100%; margin-top: 0.25rem; padding-bottom: 0.5rem; flex-shrink: 0; 
        }
        .genre-participant-overlay {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0,0,0,0.65); 
            color: white; display: flex; flex-direction: column; align-items: center; justify-content: center;
            text-align: center; padding: 0.25rem; border-radius: 0.375rem; opacity: 0; 
            transition: opacity 0.3s ease-in-out; pointer-events: none; 
        }
        .genre-legend-item.assigned .genre-participant-overlay { opacity: 1; }
        .genre-participant-overlay .name {
            font-weight: bold; font-size: 1.25rem; word-break: break-word; text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
        }
         .genre-participant-overlay .tag {
            font-size: 0.9rem; background-color: #ef4444; color: white; padding: 0.2rem 0.5rem; 
            border-radius: 0.25rem; margin-top: 0.3rem; text-transform: uppercase; font-weight: bold;
        }
        /* Estilos base para os containers de exporta√ß√£o */
        .export-base-container { 
            font-family: 'Inter', sans-serif; 
            color: #e2e8f0; /* Cor de texto padr√£o */
            padding: 24px; 
            background-color: #0f172a; 
            border: 2px solid #0ea5e9; 
            border-radius: 0.5rem; 
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            width: 800px; /* Largura fixa para consist√™ncia */
            position: absolute; /* Para renderiza√ß√£o fora da tela */
            left: -9999px; /* Posiciona fora da tela */
            line-height: 1.5; /* Line-height padr√£o */
        }
    </style>
</head>
<body class="bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 text-white min-h-screen flex flex-col items-center p-4 sm:p-6 md:p-8">

    <div id="customAlert" class="fixed top-5 right-5 text-white p-3 sm:p-4 rounded-lg shadow-lg items-start z-[120] max-w-xs sm:max-w-sm hidden">
        <div class="flex items-start">
            <span id="alertIcon" class="mr-2 h-5 w-5 sm:h-6 sm:w-6 flex-shrink-0 mt-0.5 text-xl"></span>
            <span id="alertMessageContent" class="text-sm sm:text-base flex-grow"></span>
        </div>
        <button id="alertCloseButton" class="absolute top-1 right-2 text-2xl font-bold leading-none flex-shrink-0">&times;</button>
        <div id="alertConfirmButtons" class="mt-3 flex justify-end space-x-2 hidden">
             <button id="alertCancelBtn" class="px-3 py-1 bg-slate-600 hover:bg-slate-500 rounded text-sm">Cancelar</button>
             <button id="alertConfirmBtn" class="px-3 py-1 bg-red-600 hover:bg-red-500 rounded text-sm">Confirmar</button>
        </div>
    </div>

    <div id="genreRevealModal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3 id="genreRevealParticipantNameModalTitle" class="text-2xl font-semibold text-indigo-400 mb-4"></h3>
            <div class="relative w-48 h-48 sm:w-56 sm:h-56 mx-auto mb-4 bg-slate-700/50 rounded-lg flex items-center justify-center overflow-hidden shadow-xl">
                <img id="genreRevealIconImg" src="" alt="√çcone do G√™nero" class="max-w-full max-h-full object-contain p-2">
            </div>
            <p id="genreRevealNameText" class="text-3xl sm:text-4xl font-bold text-green-400 mb-2"></p>
            <p class="text-slate-300 mb-1">N√∫mero Sorteado:</p>
            <p id="genreRevealNumberText" class="text-5xl sm:text-6xl font-extrabold text-yellow-400 mb-6"></p>
            <button id="closeGenreRevealModalButton" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-6 rounded-lg">OK</button>
        </div>
    </div>
    
    <div id="animeRevealModal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3 id="animeRevealParticipantName" class="text-2xl font-semibold text-indigo-400 mb-4"></h3>
            <img id="animeRevealCover" src="https://placehold.co/150x225/1e293b/4f46e5?text=Anime" alt="Capa do Anime Sorteado" class="w-36 h-auto mx-auto mb-4 rounded-md shadow-lg">
            <a id="animeRevealTitleLink" href="#" target="_blank" class="text-2xl sm:text-3xl font-bold text-green-400 mb-1 hover:underline"></a>
            <div id="animeRevealScore" class="text-xl sm:text-2xl font-bold my-2"></div>
            <p class="text-slate-300 mb-1">Indicado por:</p>
            <p id="animeRevealIndicator" class="text-lg sm:text-xl font-medium text-yellow-400 mb-6"></p>
            <button id="closeAnimeRevealModalButton" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-6 rounded-lg">OK</button>
        </div>
    </div>

    <div id="searchResultsModal" class="modal-overlay hidden">
        <div class="search-results-modal-content">
            <h3 class="text-xl font-semibold text-sky-400 mb-4">Resultados da Busca - Selecione um Anime</h3>
            <div id="searchResultsList" class="space-y-2 mb-4">
                </div>
            <button id="closeSearchResultsModalButton" class="bg-slate-600 hover:bg-slate-500 text-white font-semibold py-2 px-4 rounded-lg">Cancelar</button>
        </div>
    </div>


    <header class="w-full max-w-4xl mb-6 sm:mb-8 text-center">
        <h1 class="text-3xl sm:text-4xl md:text-5xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-pink-500 via-red-500 to-yellow-500 pb-1 sm:pb-2">
            Anime Bingo
        </h1>
        <p id="currentGameNameDisplay" class="text-lg sm:text-xl text-indigo-300 mt-4"></p> 
        <p id="userIdDisplay" class="text-xs mt-1 text-slate-400"></p>
    </header>

    <main class="w-full max-w-4xl bg-slate-800 bg-opacity-70 backdrop-blur-md p-4 sm:p-6 md:p-8 rounded-xl shadow-2xl">
        <section id="gameManagementSection" class="hidden">
            <h2 class="text-xl sm:text-2xl md:text-3xl font-semibold mb-6 text-sky-400 flex items-center">
                <span role="img" aria-label="controle de video game" class="mr-3 text-2xl">üéÆ</span> Gerenciar Bingos
            </h2>
            <div class="mb-6">
                <h3 class="text-lg font-medium text-indigo-300 mb-2">Criar Novo Bingo</h3>
                <div class="flex flex-col sm:flex-row gap-3 mb-3">
                    <input type="text" id="newGameNameInput" placeholder="Nome do Novo Bingo" class="flex-grow p-3 rounded-lg bg-slate-700 border border-slate-600 focus:ring-2 focus:ring-sky-500 outline-none placeholder-slate-400">
                </div>
                 <div class="flex flex-col sm:flex-row gap-3">
                    <select id="newGameModeSelect" class="flex-grow p-3 rounded-lg bg-slate-700 border border-slate-600 focus:ring-2 focus:ring-sky-500 outline-none text-slate-300">
                        <option value="infinito">Anime Bingo Infinito</option>
                        <option value="tradicional">Anime Bingo Tradicional</option>
                        <option value="clube_sorteado">Anime Bingo Clube (G√™nero Sorteado)</option>
                        <option value="clube_escolhido">Anime Bingo Clube (G√™nero Escolhido)</option>
                    </select>
                    <button id="createNewGameButton" class="bg-sky-600 hover:bg-sky-700 text-white font-semibold py-3 px-5 rounded-lg flex items-center justify-center">
                        <span role="img" aria-label="mais" class="mr-2 text-lg">‚ûï</span> Criar Bingo
                    </button>
                </div>
            </div>
            <div class="mb-6">
                <h3 class="text-lg font-medium text-indigo-300 mb-2">Bingos Salvos</h3>
                <div id="savedGamesList" class="space-y-2 max-h-60 overflow-y-auto pr-2">
                    <p class="text-slate-400">Nenhum bingo salvo ainda.</p>
                </div>
            </div>

            <div class="mt-8 pt-6 border-t border-slate-700">
                <h3 class="text-lg font-medium text-indigo-300 mb-3">Backup e Restaura√ß√£o de Dados</h3>
                <div class="space-y-4">
                    <div>
                        <label for="importFileInput" class="block text-sm font-medium text-slate-300 mb-1 w-full text-left sm:text-left">Importar Dados de Bingos (arquivo .json):</label>
                        <div class="flex flex-col items-end sm:flex-row sm:items-center gap-3">
                            <input type="file" id="importFileInput" accept=".json" class="w-full sm:flex-grow p-0 text-sm text-slate-300 rounded-lg bg-slate-700 border border-slate-600 file:mr-3 file:py-2.5 file:px-4 file:rounded-l-md file:border-0 file:text-sm file:font-semibold file:bg-indigo-600 file:text-white hover:file:bg-indigo-700 cursor-pointer focus:outline-none focus:ring-2 focus:ring-sky-500 focus:border-sky-500">
                            <button id="importGamesButton" class="bg-green-600 hover:bg-green-700 text-white font-semibold py-2.5 px-5 rounded-lg flex items-center justify-center flex-shrink-0">
                                <span role="img" aria-label="importar" class="mr-2 text-lg">üì•</span> Importar
                            </button>
                        </div>
                    </div>
                    <div>
                        <button id="exportAllGamesButton" class="w-full sm:w-auto bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2.5 px-5 rounded-lg flex items-center justify-center">
                            <span role="img" aria-label="exportar" class="mr-2 text-lg">üì§</span> Exportar Todos os Dados
                        </button>
                    </div>
                </div>
            </div>
        </section>

        <div id="actualGameContent" class="hidden">
            <section id="registrationPhaseSection">
                <h2 class="text-xl sm:text-2xl md:text-3xl font-semibold mb-6 text-indigo-400 flex items-center"><span role="img" aria-label="√≠cone de usu√°rios" class="mr-3 text-2xl">üë•</span> Cadastro de Participantes</h2>
                <div class="flex flex-col sm:flex-row gap-4 mb-6">
                    <input type="text" id="participantNameInput" placeholder="Nome do Participante" class="flex-grow p-3 rounded-lg bg-slate-700 border border-slate-600 focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 outline-none placeholder-slate-400"/>
                    <button id="addParticipantButton" class="bg-indigo-600 hover:bg-indigo-700 disabled:bg-slate-600 text-white font-semibold py-3 px-6 rounded-lg flex items-center justify-center"><span role="img" aria-label="adicionar" class="mr-2 text-lg">+</span> Adicionar</button>
                </div>
                <p id="maxParticipantsWarning" class="text-sm text-yellow-400 mb-4 p-3 bg-yellow-900 bg-opacity-50 rounded-md border border-yellow-700 hidden"><span role="img" aria-label="informa√ß√£o" class="inline mr-2">‚ÑπÔ∏è</span> M√°ximo de participantes atingido.</p>
                <div id="participantsList" class="space-y-3 mb-8 max-h-60 overflow-y-auto pr-2"></div>
                <button id="goToNextPhaseFromRegistrationButton" class="w-full bg-cyan-600 hover:bg-cyan-700 text-white font-bold py-3 px-6 rounded-lg text-lg flex items-center justify-center hidden"><span role="img" aria-label="dado" class="mr-2 text-xl">üé≤</span> Pr√≥xima Fase</button>
            </section>

            <section id="individualDrawPhaseSection" class="hidden">
                <h2 class="text-xl sm:text-2xl md:text-3xl font-semibold mb-6 text-cyan-400 flex items-center"><span role="img" aria-label="dado" class="mr-3 text-2xl">üé≤</span> Sorteio Individual de G√™neros</h2>
                <div class="mb-6"><h3 class="text-lg font-medium text-indigo-300 mb-2">Participantes Aguardando Sorteio:</h3><div id="participantsToDrawList" class="space-y-3 max-h-48 overflow-y-auto pr-2 border border-slate-700 rounded-lg p-3"></div></div>
                <div class="mb-6"><h3 class="text-lg font-medium text-slate-400 mb-2">G√™neros J√° Sorteados:</h3><div id="drawnParticipantsList" class="space-y-2 text-sm text-slate-500"></div></div>
                <button id="goToIndicationPhaseButton" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg text-lg flex items-center justify-center hidden"><span role="img" aria-label="caneta" class="mr-2 text-xl">‚úèÔ∏è</span> Prosseguir para Indica√ß√µes de Anime</button>
            </section>

            <section id="clubGenreSetupPhaseSection" class="hidden">
                <h2 class="text-xl sm:text-2xl md:text-3xl font-semibold mb-6 text-pink-400 flex items-center"><span role="img" aria-label="alvo" class="mr-3 text-2xl">üéØ</span> G√™nero do Clube</h2>
                <div id="clubGenreDrawModeContent" class="hidden">
                    <p class="mb-4 text-lg text-slate-300">Clique abaixo para sortear um g√™nero para todo o clube!</p>
                    <button id="drawClubGenreButton" class="bg-pink-600 hover:bg-pink-700 text-white font-bold py-3 px-6 rounded-lg text-lg mb-4">Sortear G√™nero do Clube</button>
                </div>
                <div id="clubGenreChooseModeContent" class="hidden">
                    <p class="mb-4 text-lg text-slate-300">Selecione um g√™nero na legenda no final da p√°gina para o clube.</p>
                    <p class="text-sm text-slate-400 mb-2">(A legenda de g√™neros precisa estar vis√≠vel)</p>
                </div>
                <div id="chosenClubGenreDisplay" class="mt-6 text-center hidden">
                    <h3 class="text-xl font-semibold text-green-400">G√™nero do Clube:</h3>
                    <div class="flex items-center justify-center gap-2 my-2">
                        <img id="chosenClubGenreIcon" src="" alt="√çcone do G√™nero do Clube" class="w-10 h-10 object-contain">
                        <p id="chosenClubGenreName" class="text-2xl font-bold"></p>
                    </div>
                </div>
                <button id="goToClubIndicationPhaseButton" class="w-full mt-6 bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg text-lg flex items-center justify-center hidden">
                    <span role="img" aria-label="caneta" class="mr-2 text-xl">‚úèÔ∏è</span> Prosseguir para Indica√ß√µes do Clube
                </button>
            </section>

            <section id="indicationPhaseSection" class="hidden">
                <h2 id="indicationPhaseTitle" class="text-xl sm:text-2xl md:text-3xl font-semibold mb-6 text-yellow-400 flex items-center"><span role="img" aria-label="caneta" class="mr-3 text-2xl">‚úèÔ∏è</span> Fase de Indica√ß√µes</h2>
                <div id="clubGenreForIndicationDisplay" class="mb-4 text-center hidden">
                    <h3 class="text-lg font-medium text-indigo-300">G√™nero do Clube para Indica√ß√£o:</h3>
                     <div class="flex items-center justify-center gap-2 my-1">
                        <img id="clubGenreForIndicationIcon" src="" alt="√çcone do G√™nero do Clube" class="w-8 h-8 object-contain">
                        <p id="clubGenreForIndicationName" class="text-xl font-semibold"></p>
                    </div>
                </div>
                <div id="indicationTabs" class="flex border-b border-slate-700 mb-4 overflow-x-auto"></div>
                <div id="indicationContent" class="space-y-4"></div>
                <div class="mt-6 flex flex-col sm:flex-row gap-3">
                    <button id="exportIndicationsButton" class="w-full sm:w-auto bg-teal-600 hover:bg-teal-700 text-white font-semibold py-2 px-4 rounded-lg text-sm">Exportar Indica√ß√µes Atuais</button>
                    <button id="goToAnimeDrawPhaseButton" class="w-full sm:flex-grow bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-6 rounded-lg text-lg flex items-center justify-center hidden"><span role="img" aria-label="televis√£o" class="mr-2 text-xl">üì∫</span> Iniciar Sorteio de Animes</button>
                </div>
            </section>
            
            <section id="animeDrawPhaseSection" class="hidden">
                 <h2 id="animeDrawPhaseTitle" class="text-xl sm:text-2xl md:text-3xl font-semibold mb-6 text-purple-400 flex items-center"><span role="img" aria-label="televis√£o" class="mr-3 text-2xl">üì∫</span> Sorteio de Anime</h2>
                 <div id="clubGenreForAnimeDrawDisplay" class="mb-4 text-center hidden">
                    <h3 class="text-lg font-medium text-indigo-300">Sorteando Anime para o G√™nero do Clube:</h3>
                     <div class="flex items-center justify-center gap-2 my-1">
                        <img id="clubGenreForAnimeDrawIcon" src="" alt="√çcone do G√™nero do Clube" class="w-8 h-8 object-contain">
                        <p id="clubGenreForAnimeDrawName" class="text-xl font-semibold"></p>
                    </div>
                </div>
                 <div id="participantsToDrawAnimeList" class="space-y-3"></div> <button id="drawClubAnimeButton" class="w-full mt-4 bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-4 rounded-lg text-lg hidden">Sortear Anime do Clube</button> <button id="goToWatchLoopButton" class="w-full mt-6 bg-orange-500 hover:bg-orange-600 text-white font-bold py-3 px-6 rounded-lg text-lg flex items-center justify-center hidden"><span role="img" aria-label="olhos" class="mr-2 text-xl">üëÄ</span> Pr√≥xima Fase</button>
            </section>

            <section id="watchLoopPhaseSection" class="hidden"> 
                <h2 id="watchLoopPhaseTitle" class="text-xl sm:text-2xl md:text-3xl font-semibold mb-6 text-teal-400 flex items-center"><span role="img" aria-label="olhos" class="mr-3 text-2xl">üëÄ</span> Acompanhamento / Resultado</h2>
                <div id="watchLoopContentIndividual" class="space-y-6"></div> 
                <div id="watchLoopContentClub" class="hidden p-4 bg-slate-700/70 rounded-lg shadow-md mb-4 text-center">
                    <h3 class="text-2xl font-semibold text-green-400 mb-3">Resultado do Bingo Clube!</h3>
                    <div id="clubResultGenre" class="mb-2">
                        <span class="text-lg text-indigo-300">G√™nero do Clube: </span>
                        <img id="clubResultGenreIcon" src="" alt="√çcone do G√™nero" class="inline-block w-6 h-6 object-contain mr-1" onerror="this.onerror=null; this.src='https://placehold.co/64x64/1e293b/4f46e5?text=Icon'; this.alt='√çcone G√™nero Padr√£o';">
                        <span id="clubResultGenreName" class="text-xl font-medium"></span>
                    </div>
                    <div id="clubResultAnime" class="mb-4">
                        <p class="text-lg text-indigo-300">Anime Sorteado para o Clube:</p>
                        <img id="clubResultAnimeCover" src="" alt="Capa do Anime" class="w-32 h-auto mx-auto my-2 rounded-md shadow-lg" onerror="this.onerror=null; this.src='https://placehold.co/150x225/1e293b/4f46e5?text=Anime'; this.alt='Capa Padr√£o';">
                        <a id="clubResultAnimeTitleLink" href="#" target="_blank" class="text-2xl font-bold text-yellow-400 hover:underline"></a>
                        <p id="clubResultAnimeIndicator" class="text-sm text-slate-400 mt-1"></p>
                    </div>
                    <div id="clubResultParticipants">
                        <p class="text-lg text-indigo-300 mb-1">Participantes do Clube:</p>
                        <div id="clubResultParticipantsList" class="text-slate-300"></div>
                    </div>
                </div>

                <div class="mt-6 flex flex-col sm:flex-row flex-wrap gap-3">
                    <button id="exportWatchListButton" class="w-full sm:w-auto bg-sky-600 hover:bg-sky-700 text-white font-semibold py-2 px-4 rounded-lg text-sm">Exportar Lista para Assistir</button>
                    <button id="exportFullIndicationHistoryButton" class="w-full sm:w-auto bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-4 rounded-lg text-sm">Exportar Hist√≥rico de Indica√ß√µes</button>
                    <button id="exportClubResultButton" class="w-full sm:w-auto bg-pink-600 hover:bg-pink-700 text-white font-semibold py-2 px-4 rounded-lg text-sm hidden">Exportar Resultado do Clube</button>
                </div>
                 <p id="allAnimesWatchedMessage" class="text-center text-2xl font-bold text-green-400 mt-8 hidden">üéâ Todos os participantes assistiram todas as suas indica√ß√µes! üéâ</p>
            </section>
            <hr class="my-8 border-slate-700">
            <button id="switchGameButton" class="w-full sm:w-auto bg-slate-600 hover:bg-slate-500 text-white font-semibold py-2 px-4 rounded-lg flex items-center justify-center text-sm mb-4"><span role="img" aria-label="trocar" class="mr-2">üîÑ</span> Trocar/Gerenciar Bingos</button>
            <button id="resetGameButton" class="w-full sm:w-auto bg-red-700 hover:bg-red-800 text-white font-semibold py-3 px-6 rounded-lg flex items-center justify-center"><span role="img" aria-label="reiniciar" class="mr-2 text-xl">üîÑ</span> Reiniciar Bingo Atual</button>
        </div>
    </main>

    <footer class="mt-12 text-center w-full md:max-w-[70rem] px-4"> 
        <div class="mb-4">
            <button id="toggleGenreLegendButton" class="text-indigo-400 hover:text-indigo-300 underline text-sm">Mostrar/Ocultar Legenda de G√™neros</button>
        </div>
        <div id="genreLegendContainer" class="hidden"> 
            <h3 class="text-xl font-semibold mb-4 text-indigo-400">G√™neros Dispon√≠veis para Sorteio</h3>
            <div id="genreGridFooter" class="grid grid-cols-2 xs:grid-cols-3 sm:grid-cols-4 md:grid-cols-5 gap-2 sm:gap-3 mx-auto"></div> 
        </div>
        <p class="text-xs text-slate-500 mt-8">Desenvolvido com <span role="img" aria-label="cora√ß√£o">‚ù§Ô∏è</span> para os f√£s de anime.<span id="footerUserId" class="block mt-1"></span></p>
    </footer>

    <script>
        let initialGenres = [
    { name: "A√ß√£o/Aventura", imageUrl: "https://raw.githubusercontent.com/marioporfirio/animebingo/c6d5c9f27e507f6ed6800bc7812f37e6a8be9188/images/acaoaventura.png" },
    { name: "Com√©dia", imageUrl: "https://raw.githubusercontent.com/marioporfirio/animebingo/c6d5c9f27e507f6ed6800bc7812f37e6a8be9188/images/comedia.png" },
    { name: "Cute Girls", imageUrl: "https://raw.githubusercontent.com/marioporfirio/animebingo/c6d5c9f27e507f6ed6800bc7812f37e6a8be9188/images/cutegirls.png" },
    { name: "Drama", imageUrl: "https://raw.githubusercontent.com/marioporfirio/animebingo/c6d5c9f27e507f6ed6800bc7812f37e6a8be9188/images/drama.png" },
    { name: "Escola M√°gica", imageUrl: "https://raw.githubusercontent.com/marioporfirio/animebingo/c6d5c9f27e507f6ed6800bc7812f37e6a8be9188/images/escolamagica.png" },
    { name: "Escolar", imageUrl: "https://raw.githubusercontent.com/marioporfirio/animebingo/c6d5c9f27e507f6ed6800bc7812f37e6a8be9188/images/escolar.png" },
    { name: "Esporte", imageUrl: "https://raw.githubusercontent.com/marioporfirio/animebingo/c6d5c9f27e507f6ed6800bc7812f37e6a8be9188/images/esporte.png" },
    { name: "Fantasia", imageUrl: "https://raw.githubusercontent.com/marioporfirio/animebingo/c6d5c9f27e507f6ed6800bc7812f37e6a8be9188/images/fantasia.png" },
    { name: "Fic√ß√£o Cient√≠fica", imageUrl: "https://raw.githubusercontent.com/marioporfirio/animebingo/7a2d1a313d228fc842e8569212f0590e7c420c95/images/ficcaocientifica.png" },
    { name: "Garota M√°gica", imageUrl: "https://raw.githubusercontent.com/marioporfirio/animebingo/c6d5c9f27e507f6ed6800bc7812f37e6a8be9188/images/garotasmagicas.png" },
    { name: "Har√©m", imageUrl: "https://raw.githubusercontent.com/marioporfirio/animebingo/c6d5c9f27e507f6ed6800bc7812f37e6a8be9188/images/harem.png" },
    { name: "Hist√≥rico", imageUrl: "https://raw.githubusercontent.com/marioporfirio/animebingo/c6d5c9f27e507f6ed6800bc7812f37e6a8be9188/images/historico.png" },
    { name: "Isekai de A√ß√£o", imageUrl: "https://raw.githubusercontent.com/marioporfirio/animebingo/c6d5c9f27e507f6ed6800bc7812f37e6a8be9188/images/isekaiacao.png" },
    { name: "Isekai de Com√©dia/Slow Life", imageUrl: "https://raw.githubusercontent.com/marioporfirio/animebingo/c6d5c9f27e507f6ed6800bc7812f37e6a8be9188/images/isekaicomedia.png" },
    { name: "Isekai de Vil√£/Santa", imageUrl: "https://raw.githubusercontent.com/marioporfirio/animebingo/c6d5c9f27e507f6ed6800bc7812f37e6a8be9188/images/isekaivilasanta.png" },
    { name: "Mecha/Espacial", imageUrl: "https://raw.githubusercontent.com/marioporfirio/animebingo/c6d5c9f27e507f6ed6800bc7812f37e6a8be9188/images/mecha.png" },
    { name: "Militar", imageUrl: "https://raw.githubusercontent.com/marioporfirio/animebingo/c6d5c9f27e507f6ed6800bc7812f37e6a8be9188/images/militar.png" },
    { name: "Mist√©rio/Policial", imageUrl: "https://raw.githubusercontent.com/marioporfirio/animebingo/c6d5c9f27e507f6ed6800bc7812f37e6a8be9188/images/misteriopolicial.png" },
    { name: "M√∫sica/Idol", imageUrl: "https://raw.githubusercontent.com/marioporfirio/animebingo/c6d5c9f27e507f6ed6800bc7812f37e6a8be9188/images/musicaidol.png" },
    { name: "P√≥s-Apocal√≠ptico", imageUrl: "https://raw.githubusercontent.com/marioporfirio/animebingo/c6d5c9f27e507f6ed6800bc7812f37e6a8be9188/images/posapocaliptico.png" },
    { name: "Profissional", imageUrl: "https://raw.githubusercontent.com/marioporfirio/animebingo/c6d5c9f27e507f6ed6800bc7812f37e6a8be9188/images/profissional.png" },
    { name: "Psicol√≥gico", imageUrl: "https://raw.githubusercontent.com/marioporfirio/animebingo/c6d5c9f27e507f6ed6800bc7812f37e6a8be9188/images/psicologico.png" },
    { name: "Romance", imageUrl: "https://raw.githubusercontent.com/marioporfirio/animebingo/c6d5c9f27e507f6ed6800bc7812f37e6a8be9188/images/romance.png" },
    { name: "Slice of Life", imageUrl: "https://raw.githubusercontent.com/marioporfirio/animebingo/c6d5c9f27e507f6ed6800bc7812f37e6a8be9188/images/slicelife.png" },
    { name: "Sobrenatural/Terror", imageUrl: "https://raw.githubusercontent.com/marioporfirio/animebingo/c6d5c9f27e507f6ed6800bc7812f37e6a8be9188/images/sobrenaturalterror.png" }
    ];
        initialGenres.sort((a, b) => a.name.localeCompare(b.name));
        initialGenres.forEach((genre, index) => {
            const startNum = index * 4 + 1;
            genre.numbers = [startNum, startNum + 1, startNum + 2, startNum + 3];
        });


        const PHASES = {
            GAME_MANAGEMENT: "GAME_MANAGEMENT", 
            REGISTRATION: "REGISTRATION",
            INDIVIDUAL_DRAW_SELECTION: "INDIVIDUAL_DRAW_SELECTION", 
            CLUB_GENRE_SETUP: "CLUB_GENRE_SETUP", 
            INDICATION: "INDICATION", 
            ANIME_DRAW_SELECTION: "ANIME_DRAW_SELECTION", 
            CLUB_ANIME_DRAW: "CLUB_ANIME_DRAW",
            WATCH_LOOP: "WATCH_LOOP", 
            CLUB_RESULT_DISPLAY: "CLUB_RESULT_DISPLAY"
        };

        const ALL_GAMES_STORAGE_KEY = 'animeBingoAllGamesData_v1';
        
        const BASE_GAME_INSTANCE_STATE = { 
            id: null, 
            name: "Anime Bingo",
            createdAt: null,
            userId: null, 
            gameMode: 'infinito', 
            currentPhase: PHASES.REGISTRATION, 
            participants: [],
            assignedGenreNames: [], 
            currentIndicatorTabId: null,
            clubGenre: null, 
            clubAnimeIndication: null,
            clubIndications: [] 
        };
        
        let allGamesData = { 
            activeGameId: null,
            games: {} 
        };
        let gameState = {}; 

        let participantNameInput, addParticipantButton, participantsListDiv, goToNextPhaseFromRegistrationButton, maxParticipantsWarning,
            registrationPhaseSection, individualDrawPhaseSection, participantsToDrawListDiv, drawnParticipantsListDiv,
            goToIndicationPhaseButton, indicationPhaseSection, indicationTabsDiv, indicationContentDiv, goToAnimeDrawPhaseButton, exportIndicationsButton,
            animeDrawPhaseSection, participantsToDrawAnimeListDiv, goToWatchLoopButton, 
            watchLoopPhaseSection, watchLoopContentDiv, allAnimesWatchedMessage, 
            resetGameButton, genreGridFooterDiv, userIdDisplay, footerUserId,
            customAlertDiv, alertIconSpan, alertMessageContentSpan, alertCloseButton, alertConfirmButtonsDiv, alertCancelBtn, alertConfirmBtn,
            genreRevealModal, genreRevealParticipantNameModalTitle, /* genreRevealIconContainer, (unused) */ genreRevealIconImg, genreRevealNameText, genreRevealNumberText, closeGenreRevealModalButton, 
            animeRevealModal, animeRevealParticipantName, animeRevealCover, animeRevealTitleLink, animeRevealIndicator, closeAnimeRevealModalButton, 
            gameManagementSection, newGameNameInput, newGameModeSelect, createNewGameButton, savedGamesListDiv, actualGameContentDiv, currentGameNameDisplay, switchGameButton,
            searchResultsModal, searchResultsListDiv, closeSearchResultsModalButton, animeRevealScore, 
            toggleGenreLegendButton, genreLegendContainer, exportWatchListButton, exportFullIndicationHistoryButton,
            importFileInput, importGamesButton, exportAllGamesButton,
            
            clubGenreSetupPhaseSection, clubGenreDrawModeContent, drawClubGenreButton, clubGenreChooseModeContent,
            chosenClubGenreDisplay, chosenClubGenreIcon, chosenClubGenreName, goToClubIndicationPhaseButton,
            indicationPhaseTitle, clubGenreForIndicationDisplay, clubGenreForIndicationIcon, clubGenreForIndicationName,
            animeDrawPhaseTitle, clubGenreForAnimeDrawDisplay, clubGenreForAnimeDrawIcon, clubGenreForAnimeDrawName, drawClubAnimeButton,
            watchLoopPhaseTitle, watchLoopContentIndividual, watchLoopContentClub,
            clubResultGenre, clubResultGenreIcon, clubResultGenreName,
            clubResultAnime, clubResultAnimeCover, clubResultAnimeTitleLink, clubResultAnimeIndicator,
            clubResultParticipants, clubResultParticipantsList, exportClubResultButton;

            
        let currentAlertResolve = null;
        let currentSearchContext = null; 

        const PLACEHOLDER_IMG_60x90 = 'https://placehold.co/60x90/1e293b/4f46e5?text=Capa';
        const PLACEHOLDER_IMG_150x225 = 'https://placehold.co/150x225/1e293b/4f46e5?text=Anime';
        const PLACEHOLDER_IMG_ERROR_60x90 = 'https://placehold.co/60x90/1e293b/ff0000?text=Erro';
        const PLACEHOLDER_IMG_SEARCH_RESULT = 'https://placehold.co/40x60/1e293b/4f46e5?text=Capa';
        const PLACEHOLDER_IMG_GENRE_ICON = 'https://placehold.co/64x64/1e293b/4f46e5?text=Icon';
        const PLACEHOLDER_IMG_ERROR_80x120 = 'https://placehold.co/80x120/1e293b/ff0000?text=Erro';
        const PLACEHOLDER_IMG_ERROR_40x60 = 'https://placehold.co/40x60/1e293b/ff0000?text=Erro';
        const PLACEHOLDER_IMG_ERROR_20x20 = 'https://placehold.co/20x20/1e293b/ff0000?text=X';


        // FUN√á√ïES PRIM√ÅRIAS
        function generateUUID() { return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => { const r = Math.random() * 16 | 0; return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16); }); }
        
        function saveAllGamesData() {
            localStorage.setItem(ALL_GAMES_STORAGE_KEY, JSON.stringify(allGamesData));
        }

        function saveCurrentGameToAllGames() {
            if (allGamesData.activeGameId && gameState && gameState.id === allGamesData.activeGameId) { 
                allGamesData.games[allGamesData.activeGameId] = { ...gameState }; 
                saveAllGamesData();
            }
        }
        
        function loadAllGamesData() {
            const savedData = localStorage.getItem(ALL_GAMES_STORAGE_KEY);
            if (savedData) {
                const parsedData = JSON.parse(savedData);
                allGamesData = { 
                    activeGameId: null, 
                    games: {}, 
                    ...parsedData 
                };
                if (!allGamesData.games) {
                    allGamesData.games = {};
                }
            } else {
                allGamesData = { activeGameId: null, games: {} };
            }

            if (allGamesData.activeGameId && allGamesData.games[allGamesData.activeGameId]) {
                const gameToLoad = JSON.parse(JSON.stringify(allGamesData.games[allGamesData.activeGameId])); 
                gameState = { 
                    ...BASE_GAME_INSTANCE_STATE, 
                    ...gameToLoad,
                    id: gameToLoad.id || generateUUID(), 
                    name: gameToLoad.name || BASE_GAME_INSTANCE_STATE.name, 
                    createdAt: gameToLoad.createdAt || new Date().toISOString(),
                    userId: gameToLoad.userId || generateUUID(),
                    gameMode: gameToLoad.gameMode || BASE_GAME_INSTANCE_STATE.gameMode,
                    currentPhase: gameToLoad.currentPhase || BASE_GAME_INSTANCE_STATE.currentPhase,
                };
                gameState.participants = (gameToLoad.participants || []).map(p => ({
                    id: p.id || generateUUID(),
                    name: p.name || "Participante Desconhecido",
                    assignedGenre: p.assignedGenre || null,
                    genreDrawNumber: p.genreDrawNumber || null,
                    currentAssignedGenre: p.currentAssignedGenre || p.assignedGenre || null, 
                    genreHistory: Array.isArray(p.genreHistory) ? [...p.genreHistory] : [], 
                    animeToWatch: p.animeToWatch ? {...p.animeToWatch} : null, 
                    receivedIndications: Array.isArray(p.receivedIndications) ? p.receivedIndications.map(ind => ({...ind})) : [], 
                    watchedAnimesHistory: Array.isArray(p.watchedAnimesHistory) ? p.watchedAnimesHistory.map(hist => ({...hist})) : []
                }));
                gameState.assignedGenreNames = Array.isArray(gameToLoad.assignedGenreNames) ? [...gameToLoad.assignedGenreNames] : [];
                gameState.clubGenre = gameToLoad.clubGenre ? {...gameToLoad.clubGenre} : null;
                gameState.clubAnimeIndication = gameToLoad.clubAnimeIndication ? {...gameToLoad.clubAnimeIndication} : null;
                gameState.clubIndications = Array.isArray(gameToLoad.clubIndications) ? gameToLoad.clubIndications.map(ind => ({...ind})) : [];
                
                gameState.currentIndicatorTabId = gameToLoad.currentIndicatorTabId || (gameState.participants[0]?.id || null);
                if (gameState.participants.length > 0 && !gameState.participants.find(p => p.id === gameState.currentIndicatorTabId)) {
                    gameState.currentIndicatorTabId = gameState.participants[0].id;
                } else if (gameState.participants.length === 0) {
                    gameState.currentIndicatorTabId = null;
                }

            } else {
                allGamesData.activeGameId = null; 
                gameState = {}; 
            }
        }


        function showAlert(message, type = 'info', duration = 3000) {
            alertMessageContentSpan.innerHTML = message;
            customAlertDiv.classList.remove('hidden', 'bg-blue-500', 'bg-green-500', 'bg-red-500', 'bg-yellow-600');
            alertConfirmButtonsDiv.classList.add('hidden');
            let iconText = '‚ÑπÔ∏è';
            if (type === 'success') { customAlertDiv.classList.add('bg-green-500'); iconText = '‚úÖ'; }
            else if (type === 'error') { customAlertDiv.classList.add('bg-red-500'); iconText = '‚ùå'; }
            else if (type === 'custom_confirm') { customAlertDiv.classList.add('bg-yellow-600'); iconText = '‚ùì'; alertConfirmButtonsDiv.classList.remove('hidden'); }
            else { customAlertDiv.classList.add('bg-blue-500'); }
            alertIconSpan.textContent = iconText;
            if (type !== 'custom_confirm' && duration !== Infinity) setTimeout(() => customAlertDiv.classList.add('hidden'), duration);
        }
        async function showConfirmAlert(message) { showAlert(message, 'custom_confirm', Infinity); return new Promise(resolve => currentAlertResolve = resolve); }

        function ensureImageIsAccessible(src, placeholderOnError) {
            return new Promise((resolve) => {
                if (!src || src.startsWith('https://placehold.co') || src.startsWith('data:image/png;base64')) {
                    resolve(src || placeholderOnError);
                    return;
                }
                const img = new Image();
                img.crossOrigin = 'anonymous'; 
                img.onload = () => resolve(src); 
                img.onerror = (err) => {
                    console.warn(`Falha ao carregar/verificar CORS para imagem: ${src}. Erro:`, err, `Usando placeholder: ${placeholderOnError}`);
                    resolve(placeholderOnError); 
                };
                img.src = src;
            });
        }


        function renderParticipantsList() {
            participantsListDiv.innerHTML = gameState.participants.length === 0 ? '<p class="text-slate-400 text-sm">Nenhum participante.</p>' : '';
            gameState.participants.forEach((p, index) => {
                const div = document.createElement('div');
                div.className = 'flex items-center justify-between bg-slate-700 p-3 rounded-lg shadow';
                div.innerHTML = `<span class="text-indigo-300">${index + 1}. ${p.name}</span>
                                         <button data-id="${p.id}" class="removeParticipantButton text-red-400 hover:text-red-300"><span role="img" aria-label="remover">üóëÔ∏è</span></button>`;
                participantsListDiv.appendChild(div);
            });
            document.querySelectorAll('.removeParticipantButton').forEach(btn => btn.onclick = e => handleRemoveParticipant(e.currentTarget.dataset.id));
            
            const maxParticipants = (gameState.gameMode === 'infinito' || gameState.gameMode === 'tradicional') ? initialGenres.length : Infinity; // No modo clube, n√£o h√° limite de participantes baseado em g√™neros
            addParticipantButton.disabled = gameState.participants.length >= maxParticipants && maxParticipants !== Infinity;
            maxParticipantsWarning.classList.toggle('hidden', gameState.participants.length < maxParticipants || maxParticipants === Infinity);
            if(maxParticipants !== Infinity) maxParticipantsWarning.innerHTML = `<span role="img" aria-label="informa√ß√£o" class="inline mr-2">‚ÑπÔ∏è</span> M√°ximo de ${maxParticipants} participantes para este modo.`;
            else maxParticipantsWarning.classList.add('hidden'); // Esconde se n√£o houver limite
            
            goToNextPhaseFromRegistrationButton.classList.toggle('hidden', gameState.participants.length === 0);
        }

        function renderIndividualDrawSelection() { 
            participantsToDrawListDiv.innerHTML = '';
            drawnParticipantsListDiv.innerHTML = '';
            let participantsYetToDraw = 0;
            gameState.participants.forEach(p => {
                if (!p.assignedGenre) { 
                    participantsYetToDraw++;
                    const div = document.createElement('div');
                    div.className = 'flex items-center justify-between bg-slate-700 p-3 rounded-lg shadow';
                    div.innerHTML = `<span class="text-indigo-300">${p.name}</span>
                                         <button data-id="${p.id}" class="draw-genre-for-participant-button bg-cyan-600 hover:bg-cyan-700 text-white font-semibold py-2 px-4 rounded-lg text-sm">Sortear para ${p.name.split(' ')[0]}</button>`;
                    participantsToDrawListDiv.appendChild(div);
                } else {
                    const li = document.createElement('li');
                    const genreDetails = initialGenres.find(g => g.name === p.assignedGenre);
                    li.innerHTML = `${p.name} - <img src="${genreDetails?.imageUrl || PLACEHOLDER_IMG_SEARCH_RESULT}" alt="${genreDetails?.name || ''}" class="inline-block w-5 h-5 object-contain mx-1 rounded-sm"> ${p.assignedGenre} (N¬∫ ${p.genreDrawNumber})`;
                    drawnParticipantsListDiv.appendChild(li);
                }
            });
            if (participantsYetToDraw === 0 && gameState.participants.length > 0) {
                 participantsToDrawListDiv.innerHTML = '<p class="text-green-400">Todos os participantes tiveram seus g√™neros iniciais sorteados!</p>';
            } else if (gameState.participants.length === 0) {
                 participantsToDrawListDiv.innerHTML = '<p class="text-slate-400">Nenhum participante para sortear.</p>';
            }
            document.querySelectorAll('.draw-genre-for-participant-button').forEach(btn => btn.onclick = e => handleIndividualGenreDraw(e.currentTarget.dataset.id));
            goToIndicationPhaseButton.classList.toggle('hidden', participantsYetToDraw > 0 || gameState.participants.length === 0);
        }
        
        function showGenreRevealModal(participantName, genre, isClubGenre = false) {
            genreRevealParticipantNameModalTitle.textContent = isClubGenre ? `G√™nero para o Clube!` :`Sorteio para ${participantName}!`; 
            genreRevealIconImg.src = genre.imageUrl || PLACEHOLDER_IMG_150x225; 
            genreRevealIconImg.alt = genre.name;
            genreRevealNameText.textContent = genre.name;
            genreRevealNumberText.textContent = genre.drawnNumber || ''; 
            genreRevealNumberText.classList.toggle('hidden', !genre.drawnNumber && !isClubGenre); 
            document.querySelector('#genreRevealModal .text-slate-300.mb-1').textContent = (isClubGenre || !genre.drawnNumber) ? 'G√™nero Sorteado/Escolhido:' : 'N√∫mero Sorteado:';

            genreRevealModal.classList.remove('hidden');
        }
        
        function renderIndicationPhase() {
            const isClubMode = gameState.gameMode === 'clube_sorteado' || gameState.gameMode === 'clube_escolhido';
            
            indicationPhaseTitle.innerHTML = `<span role="img" aria-label="caneta" class="mr-3 text-2xl">‚úèÔ∏è</span> ${isClubMode ? 'Indica√ß√µes para o Clube' : 'Fase de Indica√ß√µes de Anime'}`;
            clubGenreForIndicationDisplay.classList.toggle('hidden', !isClubMode || !gameState.clubGenre);
            
            if (isClubMode && gameState.clubGenre) {
                clubGenreForIndicationIcon.src = gameState.clubGenre.imageUrl || PLACEHOLDER_IMG_GENRE_ICON;
                clubGenreForIndicationName.textContent = gameState.clubGenre.name;
            }

            indicationTabsDiv.innerHTML = ''; 
            indicationContentDiv.innerHTML = ''; 

            if (isClubMode) {
                gameState.participants.forEach(indicator => {
                    const indicatorDiv = document.createElement('div');
                    indicatorDiv.className = 'mb-4 p-3 bg-slate-700/50 rounded-lg';
                    indicatorDiv.innerHTML = `<h4 class="text-lg font-semibold text-indigo-300 mb-2">Indica√ß√£o de ${indicator.name} para o g√™nero "${gameState.clubGenre?.name || 'N/D'}"</h4>`;
                    
                    const existingIndication = gameState.clubIndications.find(ind => ind.indicatorId === indicator.id);

                    if (existingIndication) {
                        indicatorDiv.innerHTML += `
                            <div class="indication-card">
                                <img src="${existingIndication.animeImageUrl || PLACEHOLDER_IMG_60x90}" alt="Capa de ${existingIndication.animeTitle}" onerror="this.onerror=null;this.src='${PLACEHOLDER_IMG_ERROR_60x90}';">
                                <div class="indication-card-info">
                                    <a href="${existingIndication.malUrl}" target="_blank" class="font-semibold text-green-400 hover:underline">${existingIndication.animeTitle}</a>
                                    ${existingIndication.score ? `<span class="score-badge ml-2">${existingIndication.score.toFixed(2)}</span>` : ''}
                                </div>
                                <button data-indicator-id="${indicator.id}" class="remove-club-indication-button text-red-400 hover:text-red-300 ml-auto p-1"><span role="img" aria-label="remover indica√ß√£o">üóëÔ∏è</span></button>
                            </div>`;
                    } else {
                        indicatorDiv.innerHTML += `
                            <div class="flex flex-col sm:flex-row gap-2 items-center">
                                <input type="text" data-indicator-id="${indicator.id}" placeholder="Nome do Anime ou URL MAL" class="club-indication-input w-full sm:flex-grow p-2 rounded bg-slate-600 border border-slate-500 placeholder-slate-400 text-sm">
                                <button data-indicator-id="${indicator.id}" class="indicate-club-anime-button bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-3 rounded-lg text-sm w-full sm:w-auto">Indicar para o Clube</button>
                            </div>`;
                    }
                    indicationContentDiv.appendChild(indicatorDiv);
                });
                document.querySelectorAll('.indicate-club-anime-button').forEach(btn => btn.onclick = handleClubIndicationSubmit);
                document.querySelectorAll('.club-indication-input').forEach(input => {
                     input.addEventListener('keypress', (event) => {
                         if (event.key === 'Enter') {
                             event.preventDefault();
                             const correspondingButton = input.nextElementSibling;
                             if (correspondingButton && correspondingButton.classList.contains('indicate-club-anime-button')) {
                                 correspondingButton.click();
                             }
                         }
                     });
                });
                document.querySelectorAll('.remove-club-indication-button').forEach(btn => btn.onclick = handleRemoveClubIndication);

                const allClubIndicationsDone = gameState.participants.length > 0 && gameState.participants.every(p => gameState.clubIndications.some(ind => ind.indicatorId === p.id));
                goToAnimeDrawPhaseButton.classList.toggle('hidden', !allClubIndicationsDone);

            } else { // Modos Infinito/Tradicional
                if (!gameState.currentIndicatorTabId && gameState.participants.length > 0) {
                    gameState.currentIndicatorTabId = gameState.participants[0].id;
                }
                gameState.participants.forEach(indicator => {
                    const tabButton = document.createElement('button');
                    tabButton.textContent = indicator.name.split(' ')[0];
                    tabButton.dataset.indicatorId = indicator.id;
                    tabButton.className = `py-2 px-4 font-medium border-b-2 transition-colors hover:border-indigo-400 hover:text-indigo-400 whitespace-nowrap ${gameState.currentIndicatorTabId === indicator.id ? 'tab-button-active' : 'border-transparent text-slate-400'}`;
                    tabButton.onclick = () => { gameState.currentIndicatorTabId = indicator.id; renderApp(); };
                    indicationTabsDiv.appendChild(tabButton);
                });

                const currentIndicator = gameState.participants.find(p => p.id === gameState.currentIndicatorTabId);
                if (!currentIndicator) return;

                const indicatorSection = document.createElement('div');
                indicatorSection.innerHTML = `<h3 class="text-xl font-semibold text-yellow-400 mb-3 mt-2">Indica√ß√µes de ${currentIndicator.name}:</h3>`;
                
                gameState.participants.forEach(receiver => {
                    if (receiver.id === currentIndicator.id) return; 
                    if (!receiver.currentAssignedGenre) return; 

                    const existingIndication = receiver.receivedIndications?.find(ind => ind.indicatorId === currentIndicator.id && ind.genreContext === receiver.currentAssignedGenre); 
                    const receiverGenreDetails = initialGenres.find(g => g.name === receiver.currentAssignedGenre); 
                    
                    const receiverDiv = document.createElement('div');
                    receiverDiv.className = 'mb-4 p-3 bg-slate-700/50 rounded-lg';
                    let receiverInfoHTML = `<p class="mb-2 text-indigo-300">Para: <span class="font-semibold">${receiver.name}</span>`;
                    if (receiverGenreDetails) {
                        receiverInfoHTML += ` - G√™nero Atual: <img src="${receiverGenreDetails.imageUrl || PLACEHOLDER_IMG_SEARCH_RESULT}" alt="${receiverGenreDetails.name}" class="inline-block w-5 h-5 object-contain mx-1 rounded-sm"> ${receiverGenreDetails.name}`;
                    }
                    receiverInfoHTML += `</p>`;
                    receiverDiv.innerHTML = receiverInfoHTML;

                    if (existingIndication) {
                        receiverDiv.innerHTML += `
                                <div class="indication-card">
                                    <img src="${existingIndication.animeImageUrl || PLACEHOLDER_IMG_60x90}" alt="Capa de ${existingIndication.animeTitle}" onerror="this.onerror=null;this.src='${PLACEHOLDER_IMG_ERROR_60x90}';">
                                    <div class="indication-card-info">
                                        <a href="${existingIndication.malUrl}" target="_blank" class="font-semibold text-green-400 hover:underline">${existingIndication.animeTitle}</a>
                                        ${existingIndication.score ? `<span class="score-badge ml-2">${existingIndication.score.toFixed(2)}</span>` : ''}
                                    </div>
                                    <button data-indicator-id="${currentIndicator.id}" data-receiver-id="${receiver.id}" class="remove-indication-button text-red-400 hover:text-red-300 ml-auto p-1"><span role="img" aria-label="remover indica√ß√£o">üóëÔ∏è</span></button>
                                </div>`;
                    } else {
                        receiverDiv.innerHTML += `
                                <div class="flex flex-col sm:flex-row gap-2 items-center">
                                    <input type="text" data-indicator-id="${currentIndicator.id}" data-receiver-id="${receiver.id}" placeholder="Nome do Anime ou URL MAL" class="indication-input w-full sm:flex-grow p-2 rounded bg-slate-600 border border-slate-500 placeholder-slate-400 text-sm">
                                    <button data-indicator-id="${currentIndicator.id}" data-receiver-id="${receiver.id}" class="indicate-anime-button bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-3 rounded-lg text-sm w-full sm:w-auto">Indicar</button>
                                </div>`;
                    }
                    indicatorSection.appendChild(receiverDiv);
                });
                indicationContentDiv.appendChild(indicatorSection);

                document.querySelectorAll('.indicate-anime-button').forEach(btn => btn.onclick = handleIndicationSubmit);
                document.querySelectorAll('.indication-input').forEach(input => {
                    input.addEventListener('keypress', (event) => {
                        if (event.key === 'Enter') {
                            event.preventDefault();
                            const correspondingButton = input.nextElementSibling; 
                            if (correspondingButton && correspondingButton.classList.contains('indicate-anime-button')) {
                                correspondingButton.click();
                            }
                        }
                    });
                });
                document.querySelectorAll('.remove-indication-button').forEach(btn => btn.onclick = handleRemoveIndication);

                let allOriginalModesDone = true;
                if (gameState.participants.length < 2 && gameState.participants.length > 0) { 
                    allOriginalModesDone = true; 
                } else if (gameState.participants.length >=2) {
                     for (const p1 of gameState.participants) { 
                         for (const p2 of gameState.participants) { 
                             if (p1.id === p2.id) continue;
                             if (!p2.currentAssignedGenre) {allOriginalModesDone = false; break;} 
                             if (!p2.receivedIndications?.find(ind => ind.indicatorId === p1.id && ind.genreContext === p2.currentAssignedGenre)) {
                                 allOriginalModesDone = false; break;
                             }
                         }
                         if (!allOriginalModesDone) break;
                     }
                } else { 
                    allOriginalModesDone = false;
                }
                goToAnimeDrawPhaseButton.classList.toggle('hidden', !allOriginalModesDone || gameState.participants.length === 0);
            }
        }

        async function handleIndicationSubmit(event, isClubIndication = false) {
            const button = event.currentTarget;
            const indicatorId = button.dataset.indicatorId;
            const receiverId = !isClubIndication ? button.dataset.receiverId : null; 
            const inputElement = isClubIndication ? 
                                 document.querySelector(`input.club-indication-input[data-indicator-id="${indicatorId}"]`) : 
                                 document.querySelector(`input.indication-input[data-indicator-id="${indicatorId}"][data-receiver-id="${receiverId}"]`);
            const inputValue = inputElement.value.trim();

            if (!inputValue) {
                showAlert("Por favor, digite o nome do anime ou uma URL do MAL.", "error");
                return;
            }

            button.disabled = true;
            button.textContent = '...';

            const malUrlMatch = inputValue.match(/myanimelist\.net\/anime\/(\d+)/);
            if (malUrlMatch && malUrlMatch[1]) {
                const malId = malUrlMatch[1];
                await fetchAnimeDetailsById(malId, indicatorId, receiverId, inputValue, isClubIndication);
            } else {
                await searchAnimeByNameOnJikan(inputValue, indicatorId, receiverId, isClubIndication);
            }
            button.disabled = false;
            button.textContent = isClubIndication ? 'Indicar para o Clube' : 'Indicar'; 
        }

        async function handleClubIndicationSubmit(event) {
            await handleIndicationSubmit(event, true);
        }
        
        function renderSearchResults(results) {
            searchResultsListDiv.innerHTML = '';
            if (results.length === 0) {
                searchResultsListDiv.innerHTML = '<p class="text-slate-400">Nenhum resultado encontrado.</p>';
                return;
            }
            results.forEach(anime => {
                const title = anime.title || anime.title_english || anime.title_japanese || "T√≠tulo Desconhecido"; 
                const imageUrl = anime.images?.jpg?.small_image_url || PLACEHOLDER_IMG_SEARCH_RESULT;
                const score = anime.score ? `<span class="score-badge">${anime.score.toFixed(2)}</span>` : '<span class="text-xs text-slate-400">N/A</span>';
                const typeYear = `${anime.type || ''}${anime.year ? ' (' + anime.year + ')' : ''}`;
                const episodes = anime.episodes ? `${anime.episodes} ep` : 'Ep. N/A';
                const genres = anime.genres?.slice(0, 2).map(g => g.name).join(', ') || 'G√™neros N/A';
                const themes = anime.themes?.slice(0, 1).map(t => t.name).join(', ') || '';
                const demographics = anime.demographics?.map(d => d.name).join(', ') || '';

                const itemDiv = document.createElement('div');
                itemDiv.className = 'search-result-item';
                itemDiv.innerHTML = `
                        <img src="${imageUrl}" alt="Capa de ${title}" onerror="this.onerror=null;this.src='${PLACEHOLDER_IMG_ERROR_60x90}';">
                        <div class="search-result-info">
                            <p class="font-semibold text-sky-300">${title}</p>
                            <p class="text-xs text-slate-300">${typeYear} - ${episodes}</p>
                            <p class="text-xs text-slate-400">${[genres, themes, demographics].filter(Boolean).join(' | ')}</p>
                        </div>
                        <div class="search-result-actions flex flex-col items-end gap-1 ml-auto">
                            ${score}
                            <button data-mal-id="${anime.mal_id}" data-mal-url="${anime.url}" class="select-search-result-button bg-green-600 hover:bg-green-700 text-white text-xs font-semibold py-1 px-2 rounded">Selecionar</button>
                        </div>
                `;
                searchResultsListDiv.appendChild(itemDiv);
            });
            document.querySelectorAll('.select-search-result-button').forEach(btn => btn.onclick = handleSearchResultSelection);
            searchResultsModal.classList.remove('hidden');
        }

        async function searchAnimeByNameOnJikan(query, indicatorId, receiverId, isClubIndication = false) {
            try {
                const response = await fetch(`https://api.jikan.moe/v4/anime?q=${encodeURIComponent(query)}&limit=10`);
                if (!response.ok) { const err = await response.json(); throw new Error(`Jikan Search API: ${response.status} - ${err.message || 'Erro'}`); }
                const data = await response.json();
                
                if (!data.data || data.data.length === 0) {
                    showAlert(`Nenhum resultado encontrado para "${query}". Tente uma URL direta do MAL.`, "info");
                    return;
                }
                currentSearchContext = { indicatorId, receiverId, isClubIndication }; 
                renderSearchResults(data.data); 
            } catch (error) {
                console.error("Erro ao buscar animes por nome:", error);
                showAlert(`Erro na busca: ${error.message}. Tente uma URL direta.`, "error");
            }
        }

        async function handleSearchResultSelection(event) {
            const button = event.currentTarget;
            const malId = button.dataset.malId;
            const malUrl = button.dataset.malUrl; 
            if (currentSearchContext && malId) {
                await fetchAnimeDetailsById(malId, currentSearchContext.indicatorId, currentSearchContext.receiverId, malUrl, currentSearchContext.isClubIndication);
            }
            searchResultsModal.classList.add('hidden');
            currentSearchContext = null; 
        }

        async function fetchAnimeDetailsById(malId, indicatorId, receiverId, originalMalUrl, isClubIndication = false) {
            try {
                const response = await fetch(`https://api.jikan.moe/v4/anime/${malId}`);
                if (!response.ok) { const err = await response.json(); throw new Error(`Jikan Detail API: ${response.status} - ${err.message || 'Erro'}`);}
                const data = await response.json(); const animeData = data.data;
                const animeTitle = animeData.title || animeData.title_english || animeData.title_japanese || 'T√≠tulo Desconhecido'; 
                const animeImageUrl = animeData.images?.jpg?.large_image_url || animeData.images?.jpg?.image_url || PLACEHOLDER_IMG_60x90;
                const score = animeData.score || null; 

                const indicator = gameState.participants.find(p => p.id === indicatorId);

                if (isClubIndication) {
                    if (!gameState.clubIndications) gameState.clubIndications = [];
                    gameState.clubIndications = gameState.clubIndications.filter(ind => ind.indicatorId !== indicatorId);
                    gameState.clubIndications.push({
                        indicatorId, 
                        indicatorName: indicator.name, 
                        malId, 
                        animeTitle, 
                        animeImageUrl, 
                        malUrl: originalMalUrl || animeData.url, 
                        score,
                        genreContext: gameState.clubGenre.name 
                    });
                    showAlert(`"${animeTitle}" indicado por ${indicator.name} para o g√™nero do clube: ${gameState.clubGenre.name}!`, "success");
                } else {
                    const receiver = gameState.participants.find(p => p.id === receiverId);
                    if (!receiver) {
                        showAlert("Erro: Destinat√°rio da indica√ß√£o n√£o encontrado.", "error");
                        return;
                    }
                    if (!receiver.receivedIndications) receiver.receivedIndications = [];
                    receiver.receivedIndications = receiver.receivedIndications.filter(ind => !(ind.indicatorId === indicatorId && ind.genreContext === receiver.currentAssignedGenre) ); 
                    
                    receiver.receivedIndications.push({ 
                        indicatorId, 
                        indicatorName: indicator.name, 
                        malId, 
                        animeTitle, 
                        animeImageUrl, 
                        malUrl: originalMalUrl || animeData.url, 
                        score, 
                        status: 'pending',
                        genreContext: receiver.currentAssignedGenre 
                    });
                    showAlert(`"${animeTitle}" indicado para ${receiver.name} (G√™nero: ${receiver.currentAssignedGenre})!`, "success");
                }
                renderApp();
            } catch (error) {
                console.error("Erro ao buscar detalhes do anime por ID:", error);
                showAlert(`Erro ao buscar detalhes: ${error.message}.`, "error");
            }
        }

        function handleRemoveIndication(event) { 
            const button = event.currentTarget;
            const indicatorId = button.dataset.indicatorId;
            const receiverId = button.dataset.receiverId;
            const receiver = gameState.participants.find(p => p.id === receiverId);
            
            if (receiver && receiver.receivedIndications) {
                const indicationToRemove = receiver.receivedIndications.find(ind => ind.indicatorId === indicatorId && ind.genreContext === receiver.currentAssignedGenre);
                if (indicationToRemove) {
                    receiver.receivedIndications = receiver.receivedIndications.filter(ind => !(ind.indicatorId === indicatorId && ind.genreContext === receiver.currentAssignedGenre));
                    showAlert(`Indica√ß√£o removida para ${receiver.name}.`, "success");
                    renderApp();
                }
            }
        }
        function handleRemoveClubIndication(event) { 
            const button = event.currentTarget;
            const indicatorId = button.dataset.indicatorId;
            if (gameState.clubIndications) {
                const indicationToRemove = gameState.clubIndications.find(ind => ind.indicatorId === indicatorId);
                if (indicationToRemove) {
                    gameState.clubIndications = gameState.clubIndications.filter(ind => ind.indicatorId !== indicatorId);
                    showAlert(`Indica√ß√£o de ${indicationToRemove.indicatorName} para o clube removida.`, "success");
                    renderApp();
                }
            }
        }


        function renderAnimeDrawPhase() { 
            const isClubMode = gameState.gameMode === 'clube_sorteado' || gameState.gameMode === 'clube_escolhido';
            animeDrawPhaseTitle.textContent = isClubMode ? "üì∫ Sorteio de Anime do Clube" : "üì∫ Sorteio de Anime para Assistir";
            
            clubGenreForAnimeDrawDisplay.classList.toggle('hidden', !isClubMode || !gameState.clubGenre);
            if (isClubMode && gameState.clubGenre) {
                clubGenreForAnimeDrawIcon.src = gameState.clubGenre.imageUrl || PLACEHOLDER_IMG_GENRE_ICON;
                clubGenreForAnimeDrawName.textContent = gameState.clubGenre.name;
            }

            participantsToDrawAnimeListDiv.classList.toggle('hidden', isClubMode);
            drawClubAnimeButton.classList.toggle('hidden', !isClubMode);
            
            participantsToDrawAnimeListDiv.innerHTML = ''; 

            if (isClubMode) {
                const allClubIndicationsMade = gameState.participants.length > 0 && gameState.participants.every(p => gameState.clubIndications.some(ind => ind.indicatorId === p.id));
                drawClubAnimeButton.disabled = !(gameState.clubIndications && gameState.clubIndications.length > 0 && allClubIndicationsMade);
                goToWatchLoopButton.classList.toggle('hidden', !gameState.clubAnimeIndication); 
            } else {
                let participantsYetToDrawAnime = 0;
                gameState.participants.forEach(p => {
                    if (!p.animeToWatch && p.currentAssignedGenre) { 
                        const indicationsForCurrentGenre = p.receivedIndications?.filter(ind => ind.status === 'pending' && ind.genreContext === p.currentAssignedGenre).length || 0;
                        if (indicationsForCurrentGenre > 0) { 
                            participantsYetToDrawAnime++;
                            const div = document.createElement('div');
                            div.className = 'flex items-center justify-between bg-slate-700 p-3 rounded-lg shadow';
                            div.innerHTML = `<span class="text-indigo-300">${p.name} (G√™nero: ${p.currentAssignedGenre})</span>
                                                 <button data-id="${p.id}" class="draw-anime-button bg-purple-600 hover:bg-purple-700 text-white font-semibold py-2 px-4 rounded-lg text-sm">Sortear Anime para ${p.name.split(' ')[0]}</button>`;
                            participantsToDrawAnimeListDiv.appendChild(div);
                        } else if (p.currentAssignedGenre) { 
                             const pEl = document.createElement('p');
                             pEl.className = 'text-slate-400';
                             pEl.innerHTML = `${p.name} - Aguardando indica√ß√µes para o g√™nero ${p.currentAssignedGenre}.`;
                             participantsToDrawAnimeListDiv.appendChild(pEl);
                        }
                    } else if (p.animeToWatch) {
                        const pEl = document.createElement('p');
                        pEl.className = 'text-slate-400';
                        pEl.innerHTML = `${p.name} - Anime j√° sorteado ou aguardando.`;
                        participantsToDrawAnimeListDiv.appendChild(pEl);
                    }
                });

                const allParticipantsHaveAnimeOrNoGenreOrNoIndications = gameState.participants.every(p => 
                    p.animeToWatch || 
                    !p.currentAssignedGenre || 
                    (p.currentAssignedGenre && (p.receivedIndications?.filter(ind => ind.status === 'pending' && ind.genreContext === p.currentAssignedGenre).length === 0))
                );

                if (participantsYetToDrawAnime === 0 && gameState.participants.length > 0 && allParticipantsHaveAnimeOrNoGenreOrNoIndications) {
                    participantsToDrawAnimeListDiv.innerHTML = '<p class="text-green-400">Todos os animes poss√≠veis foram sorteados ou aguardam indica√ß√µes!</p>';
                } else if (gameState.participants.length === 0) {
                    participantsToDrawAnimeListDiv.innerHTML = '<p class="text-slate-400">Nenhum participante.</p>';
                }
                document.querySelectorAll('.draw-anime-button').forEach(btn => btn.onclick = e => handleDrawAnimeForParticipant(e.currentTarget.dataset.id)); 
                goToWatchLoopButton.classList.toggle('hidden', participantsYetToDrawAnime > 0 || gameState.participants.length === 0);
            }
        }
        
        function handleDrawAnimeForParticipant(viewerId) { 
            const viewer = gameState.participants.find(p => p.id === viewerId);
            if (!viewer || viewer.animeToWatch) return; 
            if (!viewer.currentAssignedGenre) {
                showAlert(`Nenhum g√™nero atual definido para ${viewer.name}. Volte para o sorteio de g√™nero.`, "error");
                return;
            }

            const pendingIndications = viewer.receivedIndications?.filter(ind => ind.status === 'pending' && ind.genreContext === viewer.currentAssignedGenre);
            if (!pendingIndications || pendingIndications.length === 0) {
                showAlert(`Nenhum anime foi indicado para ${viewer.name} no g√™nero ${viewer.currentAssignedGenre}. Redirecionando para indica√ß√µes.`, "error");
                gameState.currentPhase = PHASES.INDICATION; 
                gameState.currentIndicatorTabId = gameState.participants.find(p => p.id !== viewerId)?.id || gameState.participants[0]?.id; 
                renderApp(); 
                return;
            }
            const randomIndex = Math.floor(Math.random() * pendingIndications.length);
            const chosenIndication = pendingIndications[randomIndex];
            
            viewer.animeToWatch = { ...chosenIndication, statusInternal: 'watching' }; 
            showAnimeRevealModal(viewer.name, viewer.animeToWatch); 
            renderApp();
        }

        function handleDrawClubAnime() {
            if (!gameState.clubIndications || gameState.clubIndications.length === 0) {
                showAlert("Nenhum anime indicado para o clube ainda!", "error");
                return;
            }
            if (gameState.participants.length > 0 && !gameState.participants.every(p => gameState.clubIndications.some(ind => ind.indicatorId === p.id))) {
                 showAlert("Ainda faltam participantes indicarem animes para o clube.", "warning");
                 return;
            }

            const randomIndex = Math.floor(Math.random() * gameState.clubIndications.length);
            const chosenClubAnime = gameState.clubIndications[randomIndex];
            gameState.clubAnimeIndication = { ...chosenClubAnime };

            showAnimeRevealModal("o Clube", gameState.clubAnimeIndication); 
            
            gameState.currentPhase = PHASES.CLUB_RESULT_DISPLAY;
            renderApp();
        }
        
        function showAnimeRevealModal(participantName, anime) { 
            animeRevealParticipantName.textContent = `Anime para ${participantName} assistir!`;
            animeRevealCover.src = anime.animeImageUrl || PLACEHOLDER_IMG_150x225;
            animeRevealCover.alt = `Capa de ${anime.animeTitle}`;
            animeRevealTitleLink.href = anime.malUrl || '#';
            animeRevealTitleLink.textContent = anime.animeTitle;
            animeRevealIndicator.textContent = anime.indicatorName;
            animeRevealScore.innerHTML = anime.score ? `<span class="score-badge">${anime.score.toFixed(2)}</span>` : '';
            animeRevealModal.classList.remove('hidden');
        }

        function renderWatchLoopPhase() {
            const isClubMode = gameState.gameMode === 'clube_sorteado' || gameState.gameMode === 'clube_escolhido';
            watchLoopPhaseTitle.textContent = isClubMode ? "üëÄ Resultado do Bingo Clube" : "üëÄ Acompanhamento de Animes";

            watchLoopContentIndividual.classList.toggle('hidden', isClubMode);
            watchLoopContentClub.classList.toggle('hidden', !isClubMode || !gameState.clubAnimeIndication);
            
            if (isClubMode) {
                exportWatchListButton.classList.add('hidden');
                exportFullIndicationHistoryButton.classList.toggle('hidden', !gameState.clubIndications || gameState.clubIndications.length === 0);
                exportClubResultButton.classList.toggle('hidden', !gameState.clubAnimeIndication);
            } else {
                exportWatchListButton.classList.remove('hidden');
                exportClubResultButton.classList.add('hidden');
                const hasAnyIndividualIndications = gameState.participants.some(p => p.receivedIndications && p.receivedIndications.length > 0);
                exportFullIndicationHistoryButton.classList.toggle('hidden', !hasAnyIndividualIndications);
            }


            if (isClubMode && gameState.clubAnimeIndication && gameState.clubGenre) {
                clubResultGenreIcon.src = gameState.clubGenre.imageUrl ? gameState.clubGenre.imageUrl : PLACEHOLDER_IMG_GENRE_ICON;
                clubResultGenreIcon.alt = gameState.clubGenre.name || '√çcone G√™nero';
                clubResultGenreName.textContent = gameState.clubGenre.name || 'G√™nero n√£o definido';

                clubResultAnimeCover.src = gameState.clubAnimeIndication.animeImageUrl ? gameState.clubAnimeIndication.animeImageUrl : PLACEHOLDER_IMG_150x225;
                clubResultAnimeCover.alt = `Capa de ${gameState.clubAnimeIndication.animeTitle || 'Anime n√£o definido'}`;
                clubResultAnimeTitleLink.href = gameState.clubAnimeIndication.malUrl || '#';
                clubResultAnimeTitleLink.textContent = gameState.clubAnimeIndication.animeTitle || 'T√≠tulo n√£o dispon√≠vel';
                clubResultAnimeIndicator.textContent = `Indicado por: ${gameState.clubAnimeIndication.indicatorName || 'Desconhecido'}`;
                
                clubResultParticipantsList.innerHTML = gameState.participants.map(p => `<span class="inline-block bg-slate-600 px-2 py-1 rounded-md text-sm mr-2 mb-2">${p.name}</span>`).join('');
            } else if (!isClubMode) {
                watchLoopContentIndividual.innerHTML = ''; 
                let allParticipantsFinishedAllCycles = true; 

                gameState.participants.forEach(p => {
                    const card = document.createElement('div');
                    card.className = 'p-4 bg-slate-700/70 rounded-lg shadow-md mb-4';
                    const genreDetails = initialGenres.find(g => g.name === p.currentAssignedGenre); 
                    let contentHTML = `<h3 class="text-xl font-semibold text-indigo-300 mb-2">${p.name}</h3>`;
                    if (genreDetails) { 
                        contentHTML += `<p class="text-sm text-slate-400 mb-2">G√™nero Atual: <img src="${genreDetails.imageUrl || PLACEHOLDER_IMG_SEARCH_RESULT}" alt="${genreDetails.name}" class="inline-block w-5 h-5 object-contain mx-1 rounded-sm"> ${genreDetails.name}</p>`;
                    } else if (p.assignedGenre && !p.currentAssignedGenre && (p.genreHistory?.length || 0) >= initialGenres.length && gameState.gameMode === 'infinito') {
                         contentHTML += `<p class="text-green-400 font-semibold">üéâ ${p.name} finalizou todos os ciclos de g√™nero!</p>`;
                    } else if (!p.currentAssignedGenre && p.assignedGenre && gameState.gameMode === 'tradicional'){ 
                        const initialGenreDetails = initialGenres.find(g => g.name === p.assignedGenre);
                        if(initialGenreDetails) contentHTML += `<p class="text-sm text-slate-400 mb-2">G√™nero Sorteado: <img src="${initialGenreDetails.imageUrl || PLACEHOLDER_IMG_SEARCH_RESULT}" alt="${initialGenreDetails.name}" class="inline-block w-5 h-5 object-contain mx-1 rounded-sm"> ${initialGenreDetails.name}</p>`;
                    }
                    
                    const pendingIndicationsForCurrentGenre = p.receivedIndications?.filter(ind => ind.status === 'pending' && ind.genreContext === p.currentAssignedGenre) || [];

                    if (p.animeToWatch && p.animeToWatch.statusInternal === 'watching') {
                        allParticipantsFinishedAllCycles = false;
                        const scoreHTML = p.animeToWatch.score ? `<span class="score-badge ml-2">${p.animeToWatch.score.toFixed(2)}</span>` : '';
                        contentHTML += `
                                <p class="text-sm text-slate-300 mb-1">Assistindo agora:</p>
                                <div class="flex items-center gap-3 mb-3 p-2 bg-slate-600 rounded">
                                    <img src="${p.animeToWatch.animeImageUrl || PLACEHOLDER_IMG_60x90}" alt="${p.animeToWatch.animeTitle}" class="w-[50px] h-[75px] object-cover rounded" onerror="this.onerror=null;this.src='${PLACEHOLDER_IMG_ERROR_60x90}';">
                                    <div>
                                        <a href="${p.animeToWatch.malUrl}" target="_blank" class="font-bold text-green-400 hover:underline">${p.animeToWatch.animeTitle}</a>
                                        ${scoreHTML}
                                        <p class="text-xs text-slate-400">Indicado por: ${p.animeToWatch.indicatorName}</p>
                                    </div>
                                </div>
                                <button data-id="${p.id}" class="mark-as-watched-button bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-4 rounded-lg text-sm w-full">Marcar como Visto</button>
                        `;
                    } else if (p.currentAssignedGenre && pendingIndicationsForCurrentGenre.length > 0) { 
                        allParticipantsFinishedAllCycles = false;
                        contentHTML += `<button data-id="${p.id}" class="draw-next-anime-button bg-cyan-600 hover:bg-cyan-700 text-white font-semibold py-2 px-4 rounded-lg text-sm w-full">Sortear Pr√≥ximo Anime (G√™nero: ${p.currentAssignedGenre})</button>`;
                    } else if (p.currentAssignedGenre && pendingIndicationsForCurrentGenre.length === 0) { 
                        allParticipantsFinishedAllCycles = false; 
                         contentHTML += `<p class="text-yellow-400 mb-2">Aguardando indica√ß√µes para o g√™nero: ${p.currentAssignedGenre}.</p>`;
                         contentHTML += `<button data-id="${p.id}" class="go-to-indicate-for-participant-button bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg text-sm w-full">Ir para Indica√ß√µes</button>`;
                         if (gameState.gameMode === 'infinito') {
                             const lastGenre = p.genreHistory && p.genreHistory.length > 0 ? p.genreHistory[p.genreHistory.length - 1] : null;
                             let availableNewGenres = initialGenres.filter(g => g.name !== lastGenre);
                             if (p.genreHistory && p.genreHistory.length >= initialGenres.length) availableNewGenres = [];
                             if (availableNewGenres.length > 0) {
                                 contentHTML += `<button data-id="${p.id}" class="draw-new-genre-button bg-orange-500 hover:bg-orange-600 text-white font-semibold py-2 px-4 rounded-lg text-sm w-full mt-2">Sortear Novo G√™nero</button>`;
                             } else if (p.receivedIndications?.filter(ind => ind.status === 'watched').length === p.receivedIndications?.length && p.receivedIndications?.length > 0){
                                contentHTML = `<p class="text-green-400 font-semibold">üéâ ${p.name} finalizou todos os ciclos de g√™nero!</p>`;
                             }
                         } else { 
                              contentHTML = `<p class="text-green-400 font-semibold">üéâ ${p.name} concluiu as indica√ß√µes para o g√™nero ${p.currentAssignedGenre}!</p>`;
                         }
                    } else if (!p.currentAssignedGenre && p.assignedGenre && gameState.gameMode === 'infinito') { 
                        allParticipantsFinishedAllCycles = false;
                        contentHTML += `<button data-id="${p.id}" class="draw-new-genre-button bg-orange-500 hover:bg-orange-600 text-white font-semibold py-2 px-4 rounded-lg text-sm w-full mt-2">Sortear Novo G√™nero</button>`;
                    } else if (!p.currentAssignedGenre && !p.assignedGenre) { 
                         allParticipantsFinishedAllCycles = false;
                         contentHTML += `<p class="text-slate-400">Aguardando sorteio inicial de g√™nero.</p>`;
                    } else { 
                        if(gameState.gameMode === 'tradicional' || (p.genreHistory && p.genreHistory.length >= initialGenres.length)) {
                            contentHTML += `<p class="text-green-400 font-semibold">üéâ ${p.name} finalizou sua participa√ß√£o!</p>`;
                        } else {
                            allParticipantsFinishedAllCycles = false; 
                            contentHTML += `<p class="text-slate-400">Aguardando pr√≥ximo passo.</p>`;
                        }
                    }

                    const watchedAnimesInHistory = p.watchedAnimesHistory || [];
                    if (watchedAnimesInHistory.length > 0) {
                        contentHTML += `<h4 class="text-sm font-medium text-slate-400 mt-4 mb-1">Animes j√° vistos:</h4><ul class="list-disc list-inside text-xs text-slate-500">`;
                        watchedAnimesInHistory.forEach(ind => {
                            const scoreText = ind.score ? ` (Nota: ${ind.score.toFixed(2)})` : '';
                            const genreContextText = ind.genreContext ? ` <span class="text-slate-400 italic">(G√™nero: ${ind.genreContext})</span>` : ''; 
                            contentHTML += `<li><a href="${ind.malUrl}" target="_blank" class="hover:underline">${ind.animeTitle}</a>${scoreText} (por ${ind.indicatorName})${genreContextText}</li>`;
                        });
                        contentHTML += `</ul>`;
                    }
                    card.innerHTML = contentHTML;
                    watchLoopContentIndividual.appendChild(card); 
                });
                
                const everyoneTrulyFinishedOriginalModes = gameState.participants.every(p => {
                    if (gameState.gameMode === 'tradicional') {
                        const pendingForCurrentGenre = p.receivedIndications?.filter(ind => ind.status === 'pending' && ind.genreContext === p.assignedGenre).length || 0;
                        return !p.animeToWatch && pendingForCurrentGenre === 0;
                    } else { // Modo Infinito
                        const lastGenre = p.genreHistory && p.genreHistory.length > 0 ? p.genreHistory[p.genreHistory.length - 1] : null;
                        let availableNewGenres = initialGenres.filter(g => g.name !== lastGenre);
                        if (p.genreHistory && p.genreHistory.length >= initialGenres.length) availableNewGenres = [];
                        return !p.animeToWatch && (p.receivedIndications?.filter(ind => ind.status === 'pending' && ind.genreContext === p.currentAssignedGenre).length === 0) && availableNewGenres.length === 0;
                    }
                });
                allAnimesWatchedMessage.classList.toggle('hidden', !everyoneTrulyFinishedOriginalModes || gameState.participants.length === 0);
            }
            
            document.querySelectorAll('.mark-as-watched-button').forEach(btn => btn.onclick = e => handleMarkAsWatched(e.currentTarget.dataset.id));
            document.querySelectorAll('.draw-next-anime-button').forEach(btn => btn.onclick = e => handleDrawNextAnimeToWatch(e.currentTarget.dataset.id));
            document.querySelectorAll('.draw-new-genre-button').forEach(btn => btn.onclick = e => drawNewGenreForParticipant(e.currentTarget.dataset.id));
            document.querySelectorAll('.go-to-indicate-for-participant-button').forEach(btn => {
                btn.onclick = (e) => {
                    const participantId = e.currentTarget.dataset.id;
                    gameState.currentIndicatorTabId = gameState.participants.find(p => p.id !== participantId)?.id || gameState.participants[0]?.id; 
                    gameState.currentPhase = PHASES.INDICATION;
                    renderApp();
                };
            });
        }
        
        function handleMarkAsWatched(participantId) {
            const participant = gameState.participants.find(p => p.id === participantId);
            if (participant && participant.animeToWatch) {
                if (!participant.watchedAnimesHistory) participant.watchedAnimesHistory = [];
                participant.watchedAnimesHistory.push({
                    ...participant.animeToWatch,
                    genreContext: participant.currentAssignedGenre 
                });

                const indicationInList = participant.receivedIndications.find(ind => 
                    ind.malId === participant.animeToWatch.malId && 
                    ind.indicatorId === participant.animeToWatch.indicatorId &&
                    ind.genreContext === participant.currentAssignedGenre 
                );
                if (indicationInList) {
                    indicationInList.status = 'watched';
                }
                
                participant.animeToWatch = null; 
                showAlert("Anime marcado como visto!", "success");

                if(gameState.gameMode === 'infinito') {
                    drawNewGenreForParticipant(participantId); 
                } else { 
                    renderApp(); 
                }
            }
        }

        function drawNewGenreForParticipant(participantId) {
            const participant = gameState.participants.find(p => p.id === participantId);
            if (!participant) return;

            const lastGenre = participant.genreHistory && participant.genreHistory.length > 0 ? participant.genreHistory[participant.genreHistory.length - 1] : null;
            
            let availableGenresForNewDraw = initialGenres.filter(g => g.name !== lastGenre);
            if (availableGenresForNewDraw.length === 0 && initialGenres.length > 0) { 
                 availableGenresForNewDraw = initialGenres; 
            }
            if (availableGenresForNewDraw.length === 0) { 
                showAlert(`Todos os g√™neros j√° foram sorteados para ${participant.name}! Ele finalizou o bingo!`, "success", 5000);
                participant.currentAssignedGenre = null; 
                renderApp(); 
                return;
            }

            const chosenNewGenre = availableGenresForNewDraw[Math.floor(Math.random() * availableGenresForNewDraw.length)];
            const newDrawnNumber = chosenNewGenre.numbers[Math.floor(Math.random() * chosenNewGenre.numbers.length)];

            participant.currentAssignedGenre = chosenNewGenre.name;
            if(!participant.genreHistory) participant.genreHistory = [];
            participant.genreHistory.push(chosenNewGenre.name); 
            
            participant.receivedIndications = participant.receivedIndications.filter(ind => ind.status === 'watched');
            
            showAlert(`Novo g√™nero sorteado para ${participant.name}: ${chosenNewGenre.name}! Indiquem animes!`, "success", 5000);
            showGenreRevealModal(participant.name, { ...chosenNewGenre, drawnNumber: newDrawnNumber, imageUrl: chosenNewGenre.imageUrl });
            
            gameState.currentPhase = PHASES.INDICATION;
            gameState.currentIndicatorTabId = gameState.participants.find(p => p.id !== participantId)?.id || gameState.participants[0]?.id; 
            renderApp(); 
        }


        function handleDrawNextAnimeToWatch(participantId) {
            const participant = gameState.participants.find(p => p.id === participantId);
            if (!participant || participant.animeToWatch) return; 

            const pendingIndications = participant.receivedIndications?.filter(ind => ind.status === 'pending' && ind.genreContext === participant.currentAssignedGenre);
            
            if (!pendingIndications || pendingIndications.length === 0) {
                showAlert(`Nenhum anime pendente indicado para ${participant.name} no g√™nero ${participant.currentAssignedGenre}. Pe√ßa indica√ß√µes!`, "info", 4000);
                if (gameState.gameMode === 'infinito') { 
                    gameState.currentPhase = PHASES.INDICATION;
                    gameState.currentIndicatorTabId = gameState.participants.find(p => p.id !== participantId)?.id || gameState.participants[0]?.id; 
                }
                renderApp(); 
                return;
            }
            const randomIndex = Math.floor(Math.random() * pendingIndications.length);
            const chosenIndication = pendingIndications[randomIndex];
            
            participant.animeToWatch = { ...chosenIndication, statusInternal: 'watching' };
            showAnimeRevealModal(participant.name, participant.animeToWatch); 
            renderApp();
        }
        
        function renderGenreGridFooter() {
            if (!genreGridFooterDiv) { return; } 
            genreGridFooterDiv.innerHTML = '';
            initialGenres.forEach(genre => { 
                const div = document.createElement('div');
                div.className = 'genre-legend-item bg-slate-700 rounded-lg shadow text-center'; 
                
                let overlayHTMLContent = ''; 
                if (gameState.gameMode === 'infinito' || gameState.gameMode === 'tradicional') {
                    const participantsWithThisGenre = gameState.participants?.filter(p => p.currentAssignedGenre === genre.name) || [];
                    if (participantsWithThisGenre.length > 0) {
                        div.classList.add('assigned'); 
                        const names = participantsWithThisGenre.map(p => p.name.split(' ')[0]).join(', '); 
                        overlayHTMLContent = `
                            <div class="genre-participant-overlay">
                                <span class="name">${names}</span>
                                <span class="tag">ATIVO</span>
                            </div>`;
                    }
                }
                
                if (gameState.gameMode === 'clube_escolhido' && gameState.currentPhase === PHASES.CLUB_GENRE_SETUP) {
                    if (gameState.clubGenre && gameState.clubGenre.name === genre.name) {
                        div.classList.add('selected-for-club');
                    }
                    div.onclick = () => handleChooseClubGenre(genre.name, genre.imageUrl, genre.numbers ? genre.numbers[0] : undefined);
                } else {
                    div.onclick = null; 
                }
                
                div.innerHTML = `
                        <div class="genre-image-wrapper">
                            <img src="${genre.imageUrl || PLACEHOLDER_IMG_GENRE_ICON}" alt="${genre.name}" onerror="this.onerror=null;this.src='${PLACEHOLDER_IMG_ERROR_60x90}';">
                        </div>
                        <p class="text-indigo-300 leading-tight">${genre.name}</p>
                        ${overlayHTMLContent}`; 
                genreGridFooterDiv.appendChild(div);
            });
        }

        function renderApp() {
            if (!allGamesData.activeGameId || !gameState || Object.keys(gameState).length === 0) { 
                gameManagementSection.classList.remove('hidden');
                actualGameContentDiv.classList.add('hidden');
                renderGameManagementScreen();
                return;
            }
            
            gameManagementSection.classList.add('hidden');
            actualGameContentDiv.classList.remove('hidden');
            
            let modeDisplayName = "Desconhecido";
            if (gameState.gameMode === 'infinito') modeDisplayName = "Infinito";
            else if (gameState.gameMode === 'tradicional') modeDisplayName = "Tradicional";
            else if (gameState.gameMode === 'clube_sorteado') modeDisplayName = "Clube (G√™nero Sorteado)";
            else if (gameState.gameMode === 'clube_escolhido') modeDisplayName = "Clube (G√™nero Escolhido)";
            currentGameNameDisplay.textContent = gameState.name ? `Bingo Atual: ${gameState.name} (${modeDisplayName})` : 'Organize seus Bingos de Anime!';


            [registrationPhaseSection, individualDrawPhaseSection, clubGenreSetupPhaseSection, indicationPhaseSection, animeDrawPhaseSection, watchLoopPhaseSection].forEach(sec => sec.classList.add('hidden'));

            if (gameState.currentPhase === PHASES.REGISTRATION) {
                registrationPhaseSection.classList.remove('hidden');
                renderParticipantsList();
            } else if (gameState.currentPhase === PHASES.INDIVIDUAL_DRAW_SELECTION && (gameState.gameMode === 'infinito' || gameState.gameMode === 'tradicional')) {
                individualDrawPhaseSection.classList.remove('hidden');
                renderIndividualDrawSelection();
            } else if (gameState.currentPhase === PHASES.CLUB_GENRE_SETUP && (gameState.gameMode === 'clube_sorteado' || gameState.gameMode === 'clube_escolhido')) {
                clubGenreSetupPhaseSection.classList.remove('hidden');
                renderClubGenreSetupPhase();
            } else if (gameState.currentPhase === PHASES.INDICATION) {
                indicationPhaseSection.classList.remove('hidden');
                renderIndicationPhase();
            } else if (gameState.currentPhase === PHASES.ANIME_DRAW_SELECTION || gameState.currentPhase === PHASES.CLUB_ANIME_DRAW) {
                animeDrawPhaseSection.classList.remove('hidden');
                renderAnimeDrawPhase();
            } else if (gameState.currentPhase === PHASES.WATCH_LOOP || gameState.currentPhase === PHASES.CLUB_RESULT_DISPLAY) {
                watchLoopPhaseSection.classList.remove('hidden');
                renderWatchLoopPhase();
            }
            
            resetGameButton.classList.toggle('hidden', !allGamesData.activeGameId || (gameState.currentPhase === PHASES.REGISTRATION && gameState.participants.length === 0) );
            
            if (allGamesData.activeGameId && gameState.id) { 
                userIdDisplay.textContent = `ID do Bingo: ${gameState.id}`; 
                footerUserId.textContent = `ID do Bingo: ${gameState.id}`; 
            } else { 
                userIdDisplay.textContent = ''; 
                footerUserId.textContent = ''; 
            }
            
            if (genreLegendContainer && !genreLegendContainer.classList.contains('hidden')) {
                 renderGenreGridFooter();
            }
            saveCurrentGameToAllGames(); 
        }

        function handleAddParticipant() {
            const name = participantNameInput.value.trim();
            if (!name) { showAlert("O nome do participante n√£o pode estar vazio.", "error"); return; }
            
            const maxParticipants = (gameState.gameMode === 'infinito' || gameState.gameMode === 'tradicional') ? initialGenres.length : Infinity; 
            if (gameState.participants.length >= maxParticipants && maxParticipants !== Infinity) { 
                showAlert(`M√°ximo de ${maxParticipants} participantes para este modo.`, "error"); return; 
            }

            if (gameState.participants.find(p => p.name.toLowerCase() === name.toLowerCase())) { showAlert("Este nome j√° existe.", "error"); return; }
            gameState.participants.push({ 
                id: generateUUID(), name, assignedGenre: null, genreDrawNumber: null, 
                currentAssignedGenre: null, genreHistory: [], 
                animeToWatch: null, receivedIndications: [], watchedAnimesHistory: []
            });
            participantNameInput.value = ""; showAlert(`${name} adicionado!`, "success"); renderApp();
        };

         function handleRemoveParticipant(participantId) {
            const pName = gameState.participants.find(p=>p.id === participantId)?.name;
            gameState.participants = gameState.participants.filter(p => p.id !== participantId);
            gameState.participants.forEach(p => {
                p.receivedIndications = p.receivedIndications.filter(ind => ind.indicatorId !== participantId);
            });
            if (gameState.clubIndications) {
                gameState.clubIndications = gameState.clubIndications.filter(ind => ind.indicatorId !== participantId);
            }

            if (gameState.currentIndicatorTabId === participantId) {
                gameState.currentIndicatorTabId = gameState.participants[0]?.id || null;
            }
            gameState.assignedGenreNames = gameState.assignedGenreNames.filter(ag => ag.participantId !== participantId);
            showAlert(`${pName} removido.`, "success"); renderApp();
        }
        
        function handleIndividualGenreDraw(participantId) { 
            const participant = gameState.participants.find(p => p.id === participantId);
            if (!participant || participant.assignedGenre) return; 
            
            const availableGenres = initialGenres.filter(g => !gameState.assignedGenreNames.some(ag => ag.genreName === g.name));
            if (availableGenres.length === 0) { showAlert("N√£o h√° mais g√™neros √∫nicos para distribuir inicialmente!", "error"); return; }
            
            const chosenGenre = availableGenres[Math.floor(Math.random() * availableGenres.length)];
            const drawnNumber = chosenGenre.numbers[Math.floor(Math.random() * chosenGenre.numbers.length)];
            
            participant.assignedGenre = chosenGenre.name; 
            participant.genreDrawNumber = drawnNumber;
            participant.currentAssignedGenre = chosenGenre.name; 
            if(!participant.genreHistory) participant.genreHistory = [];
            participant.genreHistory.push(chosenGenre.name); 

            gameState.assignedGenreNames.push({participantId: participant.id, genreName: chosenGenre.name}); 
            showGenreRevealModal(participant.name, { ...chosenGenre, drawnNumber: drawnNumber, imageUrl: chosenGenre.imageUrl });
            renderApp(); 
        }
        
        async function handleResetGame() {
            if (await showConfirmAlert('<p class="font-semibold mb-2">Confirmar Rein√≠cio do Bingo Atual</p><p>Isso ir√° manter os participantes, mas limpar√° todos os g√™neros sorteados, animes indicados e progresso de visualiza√ß√£o. Deseja prosseguir?</p>')) {
                const currentGameId = allGamesData.activeGameId;
                if (currentGameId && allGamesData.games[currentGameId]) {
                    const currentParticipantsData = allGamesData.games[currentGameId].participants.map(p => ({
                        id: p.id,
                        name: p.name,
                        assignedGenre: null,
                        genreDrawNumber: null,
                        currentAssignedGenre: null,
                        genreHistory: [],
                        receivedIndications: [],
                        watchedAnimesHistory: [],
                        animeToWatch: null
                    }));

                    allGamesData.games[currentGameId] = {
                        ...BASE_GAME_INSTANCE_STATE, 
                        id: currentGameId,
                        name: allGamesData.games[currentGameId].name, 
                        gameMode: allGamesData.games[currentGameId].gameMode || 'infinito', 
                        createdAt: allGamesData.games[currentGameId].createdAt, 
                        userId: allGamesData.games[currentGameId].userId || generateUUID(), 
                        participants: currentParticipantsData, 
                        currentPhase: PHASES.REGISTRATION,
                        assignedGenreNames: [],
                        clubGenre: null,
                        clubAnimeIndication: null,
                        clubIndications: []
                    };
                    
                    gameState = { ...allGamesData.games[currentGameId] };
                    showAlert("Bingo reiniciado! Os participantes foram mantidos.", "success", 4000); 
                    renderApp(); 
                } else {
                    showAlert("Nenhum bingo ativo para reiniciar.", "error");
                }
            }
        };

        function createNewGame() {
            const gameName = newGameNameInput.value.trim();
            const gameMode = newGameModeSelect.value;
            if (!gameName) { showAlert("Por favor, d√™ um nome ao novo bingo.", "error"); return; }
            const newGameId = generateUUID();
            const newGame = {
                ...BASE_GAME_INSTANCE_STATE,
                id: newGameId,
                name: gameName,
                gameMode: gameMode,
                createdAt: new Date().toISOString(),
                userId: generateUUID(),
                participants: [], 
                assignedGenreNames: [],
                clubGenre: null,
                clubAnimeIndication: null,
                clubIndications: []
            };
            allGamesData.games[newGameId] = newGame;
            allGamesData.activeGameId = newGameId;
            gameState = { ...newGame }; 
            newGameNameInput.value = '';
            let modeDisplayName = "Desconhecido";
            if (gameMode === 'infinito') modeDisplayName = "Infinito";
            else if (gameMode === 'tradicional') modeDisplayName = "Tradicional";
            else if (gameMode === 'clube_sorteado') modeDisplayName = "Clube (G√™nero Sorteado)";
            else if (gameMode === 'clube_escolhido') modeDisplayName = "Clube (G√™nero Escolhido)";
            showAlert(`Bingo "${gameName}" (Modo: ${modeDisplayName}) criado e carregado!`, "success");
            saveAllGamesData(); 
            renderApp(); 
        }

        function loadSelectedGame(gameId) {
            const gameDataFromStorage = allGamesData.games[gameId];

            if (gameDataFromStorage) {
                allGamesData.activeGameId = gameId; 

                gameState = JSON.parse(JSON.stringify(BASE_GAME_INSTANCE_STATE));
                const loadedGameData = JSON.parse(JSON.stringify(gameDataFromStorage));
                
                // Merge top-level properties
                for (const key in loadedGameData) {
                    if (Object.prototype.hasOwnProperty.call(loadedGameData, key) && 
                        key !== 'participants' && 
                        key !== 'assignedGenreNames' && 
                        key !== 'clubIndications' &&
                        key !== 'clubGenre' && 
                        key !== 'clubAnimeIndication' && 
                        key !== 'animeToWatch') { // animeToWatch is per participant
                        if (loadedGameData[key] !== undefined) {
                            gameState[key] = loadedGameData[key];
                        }
                    }
                }
                // Ensure critical properties have fallbacks
                gameState.id = loadedGameData.id || gameState.id || generateUUID();
                gameState.name = loadedGameData.name || gameState.name; // gameState.name is from BASE
                gameState.createdAt = loadedGameData.createdAt || gameState.createdAt || new Date().toISOString();
                gameState.userId = loadedGameData.userId || gameState.userId || generateUUID();
                gameState.gameMode = loadedGameData.gameMode || gameState.gameMode;
                gameState.currentPhase = loadedGameData.currentPhase || gameState.currentPhase;


                gameState.participants = (loadedGameData.participants || []).map(p_in => {
                    return {
                        id: p_in.id || generateUUID(),
                        name: p_in.name || "Participante Desconhecido",
                        assignedGenre: p_in.assignedGenre || null,
                        genreDrawNumber: p_in.genreDrawNumber || null,
                        currentAssignedGenre: p_in.currentAssignedGenre || p_in.assignedGenre || null,
                        genreHistory: Array.isArray(p_in.genreHistory) ? [...p_in.genreHistory] : [],
                        animeToWatch: p_in.animeToWatch ? { ...p_in.animeToWatch } : null,
                        receivedIndications: Array.isArray(p_in.receivedIndications) ? p_in.receivedIndications.map(ind => ({ ...ind })) : [],
                        watchedAnimesHistory: Array.isArray(p_in.watchedAnimesHistory) ? p_in.watchedAnimesHistory.map(hist => ({ ...hist })) : []
                    };
                });
                
                gameState.assignedGenreNames = Array.isArray(loadedGameData.assignedGenreNames) ? [...loadedGameData.assignedGenreNames] : [];
                gameState.clubGenre = loadedGameData.clubGenre ? { ...loadedGameData.clubGenre } : null;
                gameState.clubAnimeIndication = loadedGameData.clubAnimeIndication ? { ...loadedGameData.clubAnimeIndication } : null;
                gameState.clubIndications = Array.isArray(loadedGameData.clubIndications) ? loadedGameData.clubIndications.map(ind => ({ ...ind })) : [];
                
                if (gameState.participants.length > 0) {
                    const isValidTabId = loadedGameData.currentIndicatorTabId && gameState.participants.find(p => p.id === loadedGameData.currentIndicatorTabId);
                    gameState.currentIndicatorTabId = isValidTabId ? loadedGameData.currentIndicatorTabId : gameState.participants[0].id;
                } else {
                    gameState.currentIndicatorTabId = null;
                }

                if (!Object.values(PHASES).includes(gameState.currentPhase)) {
                    console.warn(`[loadSelectedGame] Fase inv√°lida "${gameState.currentPhase}" carregada para o jogo "${gameState.name}". Redefinindo para REGISTRATION.`);
                    gameState.currentPhase = PHASES.REGISTRATION;
                }
                
                const displayNameForAlert = gameState.name || "Bingo Carregado"; 
                showAlert(`Bingo "${displayNameForAlert}" carregado!`, "success");
                
                saveAllGamesData(); 
                renderApp();    
            } else {
                showAlert("Erro ao carregar o bingo: Jogo com ID especificado n√£o encontrado.", "error");
            }
        }


        function deleteGame(gameId) {
            const gameToDelete = allGamesData.games[gameId];
            if (!gameToDelete) return;
            showConfirmAlert(`<p class="font-semibold mb-2">Confirmar Exclus√£o</p><p>Tem certeza que deseja excluir o bingo "${gameToDelete.name}"? Esta a√ß√£o n√£o pode ser desfeita.</p>`)
            .then(confirmed => {
                if (confirmed) {
                    delete allGamesData.games[gameId];
                    if (allGamesData.activeGameId === gameId) {
                        allGamesData.activeGameId = null;
                        gameState = {}; 
                    }
                    showAlert(`Bingo "${gameToDelete.name}" exclu√≠do.`, "success");
                    saveAllGamesData();
                    renderApp(); 
                }
            });
        }

        function renderGameManagementScreen() {
            actualGameContentDiv.classList.add('hidden');
            gameManagementSection.classList.remove('hidden');
            currentGameNameDisplay.textContent = 'Gerenciador de Bingos';
            userIdDisplay.textContent = ''; 
            footerUserId.textContent = '';
            savedGamesListDiv.innerHTML = '';
            const gameIds = Object.keys(allGamesData.games);
            if (gameIds.length === 0) {
                savedGamesListDiv.innerHTML = '<p class="text-slate-400">Nenhum bingo salvo ainda.</p>';
            } else {
                gameIds.forEach(id => {
                    const game = allGamesData.games[id];
                    let modeDisplayName = "Desconhecido";
                    if (game.gameMode === 'infinito') modeDisplayName = "Infinito";
                    else if (game.gameMode === 'tradicional') modeDisplayName = "Tradicional";
                    else if (game.gameMode === 'clube_sorteado') modeDisplayName = "Clube (G√™nero Sorteado)";
                    else if (game.gameMode === 'clube_escolhido') modeDisplayName = "Clube (G√™nero Escolhido)";

                    const gameItem = document.createElement('div');
                    gameItem.className = 'game-list-item';
                    gameItem.innerHTML = `
                            <span>${game.name || 'Bingo Sem Nome'} <em class="text-xs text-slate-400 ml-2">(Modo: ${modeDisplayName})</em></span>
                            <div>
                                <button data-game-id="${id}" class="load-game-button bg-green-600 hover:bg-green-700 text-white text-xs font-semibold py-1 px-2 rounded mr-2">Carregar</button>
                                <button data-game-id="${id}" class="delete-game-button text-red-400 hover:text-red-300 p-1"><span role="img" aria-label="excluir bingo">üóëÔ∏è</span></button>
                            </div>
                    `;
                    savedGamesListDiv.appendChild(gameItem);
                });
                document.querySelectorAll('.load-game-button').forEach(btn => btn.onclick = (e) => loadSelectedGame(e.currentTarget.dataset.gameId));
                document.querySelectorAll('.delete-game-button').forEach(btn => btn.onclick = (e) => deleteGame(e.currentTarget.dataset.gameId));
            }
        }
        
        async function exportAnimeWatchList() {
             if(exportWatchListButton) exportWatchListButton.disabled = true;
            showAlert("Preparando exporta√ß√£o da lista para assistir...", "info", Infinity);

            try {
                await document.fonts.ready; 

                const exportContentDiv = document.createElement('div');
                exportContentDiv.id = 'exportImageContainer'; 
                exportContentDiv.className = 'export-base-container';
                document.body.appendChild(exportContentDiv);

                let listContentHTML = `<h3 style="font-family: 'Inter', sans-serif; font-size: 32px; font-weight: 700; color: #38bdf8; margin-bottom: 24px; padding-bottom: 12px; text-align: center; line-height: 1.2; letter-spacing: normal; text-rendering: optimizeLegibility; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;">Lista de Animes para Assistir - ${gameState.name || 'Bingo'}</h3>`;
                let hasAnimesToWatch = false;

                const imageLoadPromises = [];
                const participantsRenderData = [];

                for (const participant of gameState.participants) {
                    if (participant.animeToWatch && participant.animeToWatch.animeTitle) {
                        hasAnimesToWatch = true;
                        const animeImageUrl = participant.animeToWatch.animeImageUrl || PLACEHOLDER_IMG_60x90;
                        
                        imageLoadPromises.push(
                            ensureImageIsAccessible(animeImageUrl, PLACEHOLDER_IMG_ERROR_80x120)
                                .then(finalUrl => {
                                    const genreDetails = initialGenres.find(g => g.name === participant.currentAssignedGenre);
                                    participantsRenderData.push({
                                        name: participant.name,
                                        genreDisplay: genreDetails ? `<span style="font-family: 'Inter', sans-serif; font-size: 16px; color: #cbd5e1; margin-left: 8px; line-height: 1.4; letter-spacing: normal; text-rendering: optimizeLegibility; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;">(G√™nero Atual: ${genreDetails.name})</span>` : '',
                                        animeTitle: participant.animeToWatch.animeTitle,
                                        finalAnimeImageUrl: finalUrl,
                                        indicatorName: participant.animeToWatch.indicatorName
                                    });
                                })
                        );
                    }
                }

                await Promise.all(imageLoadPromises.map(p => p.catch(e => e))); 

                if (!hasAnimesToWatch) {
                    listContentHTML += '<p style="font-family: \'Inter\', sans-serif; font-size: 18px; text-align: center; color: #94a3b8; margin-top: 16px; line-height: 1.4; letter-spacing: normal; text-rendering: optimizeLegibility; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;">Nenhum anime sorteado para assistir no momento.</p>';
                } else {
                    const orderedRenderData = [];
                    gameState.participants.forEach(p => {
                        const found = participantsRenderData.find(r => r.name === p.name && r.animeTitle === p.animeToWatch?.animeTitle);
                        if (found) orderedRenderData.push(found);
                    });

                    orderedRenderData.forEach(pData => {
                        listContentHTML += `
                                <div style="padding: 16px 0; border-bottom: 1px solid #334155; margin-bottom: 16px;">
                                    <h4 style="font-family: 'Inter', sans-serif; font-size: 26px; font-weight: 600; color: #a5b4fc; margin-bottom: 16px; line-height: 1.3; letter-spacing: normal; text-rendering: optimizeLegibility; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;">${pData.name} ${pData.genreDisplay}</h4>
                                    <div style="display: flex; align-items: center; gap: 20px; margin-left: 12px; padding-top: 8px;">
                                        <img src="${pData.finalAnimeImageUrl}" alt="Capa do anime ${pData.animeTitle}" style="width: 80px; height: 120px; object-fit: cover; border-radius: 4px; flex-shrink: 0; border: 1px solid #475569; overflow: hidden;" onerror="this.src='${PLACEHOLDER_IMG_ERROR_80x120}'">
                                        <div style="text-align: left; padding-top: 4px;">
                                            <p style="font-family: 'Inter', sans-serif; font-size: 22px; color: #f1f5f9; font-weight: 500; margin-bottom: 8px; line-height: 1.3; letter-spacing: normal; text-rendering: optimizeLegibility; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;">${pData.animeTitle}</p>
                                            <p style="font-family: 'Inter', sans-serif; font-size: 18px; color: #cbd5e1; line-height: 1.4; letter-spacing: normal; text-rendering: optimizeLegibility; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;">Indicado por: ${pData.indicatorName}</p>
                                        </div>
                                    </div>
                                </div>`;
                    });
                }
                exportContentDiv.innerHTML = listContentHTML;
                
                void exportContentDiv.offsetHeight; 
                await new Promise(resolve => setTimeout(resolve, 1000));


                const canvas = await html2canvas(exportContentDiv, { 
                    backgroundColor: '#0f172a', 
                    useCORS: true, 
                    scale: 2, 
                    logging: true,
                    windowWidth: exportContentDiv.scrollWidth,
                    windowHeight: exportContentDiv.scrollHeight
                });
                const imageURL = canvas.toDataURL('image/png');
                const link = document.createElement('a');
                link.href = imageURL;
                link.download = `lista_animes_assistir_${gameState.name.replace(/\s+/g, '_') || 'bingo'}.png`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                showAlert("Lista de animes exportada como imagem!", "success");

            } catch (error) {
                console.error("Erro ao exportar imagem da lista para assistir:", error);
                showAlert("Erro ao exportar imagem. Verifique o console.", "error");
            } finally {
                if (document.getElementById('exportImageContainer')) { 
                    document.body.removeChild(document.getElementById('exportImageContainer'));
                }
                if(exportWatchListButton) exportWatchListButton.disabled = false;
                customAlertDiv.classList.add('hidden'); 
            }
        }

        async function exportIndicationsList(exportType) {
            const exportButton = exportType === 'current' ? exportIndicationsButton : exportFullIndicationHistoryButton;
            if(exportButton) exportButton.disabled = true;
            showAlert(`Preparando exporta√ß√£o do ${exportType === 'current' ? 'hist√≥rico atual' : 'hist√≥rico completo'}...`, "info", Infinity);
            
            try {
                await document.fonts.ready;

                const containerId = 'exportAllIndicationsContainer';
                let exportContentDiv = document.getElementById(containerId);
                if (exportContentDiv) exportContentDiv.remove(); 

                exportContentDiv = document.createElement('div');
                exportContentDiv.id = containerId;
                exportContentDiv.className = 'export-base-container'; 
                document.body.appendChild(exportContentDiv);

                const titleText = exportType === 'current' ? "Indica√ß√µes Atuais para os G√™neros Ativos" : "Hist√≥rico Completo de Todas as Indica√ß√µes";
                let listContentHTML = `<h3 style="font-family: 'Inter', sans-serif; font-size: 30px; font-weight: 700; color: #38bdf8; text-align: center; margin-bottom: 20px; padding-bottom: 10px; line-height: 1.2; letter-spacing: normal; text-rendering: optimizeLegibility; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;">${titleText} - ${gameState.name || 'Bingo'}</h3>`;
                let hasAnyIndications = false;

                const allImagePromises = [];
                const receiversRenderData = []; 

                for (const receiver of gameState.participants) {
                    const receiverData = { name: receiver.name, indicationsByGenre: {} };
                    let hasIndicationsForThisReceiver = false;

                    const indicationsByGenreContext = {};
                    (receiver.receivedIndications || []).forEach(ind => {
                        if (exportType === 'current' && ind.status !== 'pending') return;
                        if (exportType === 'current' && ind.genreContext !== receiver.currentAssignedGenre) return;
                        if (!indicationsByGenreContext[ind.genreContext]) indicationsByGenreContext[ind.genreContext] = [];
                        indicationsByGenreContext[ind.genreContext].push(ind);
                    });

                    for (const genreCtx of Object.keys(indicationsByGenreContext)) {
                        if (indicationsByGenreContext[genreCtx].length > 0) {
                            hasIndicationsForThisReceiver = true;
                            hasAnyIndications = true;
                            
                            const genreDetails = initialGenres.find(g => g.name === genreCtx);
                            const genreIconUrl = genreDetails ? genreDetails.imageUrl : PLACEHOLDER_IMG_GENRE_ICON;
                            
                            const genreIconPromise = ensureImageIsAccessible(genreIconUrl, PLACEHOLDER_IMG_ERROR_20x20)
                                .then(finalUrl => ({ genreCtx, finalUrl }));
                            allImagePromises.push(genreIconPromise);

                            receiverData.indicationsByGenre[genreCtx] = { genreIconPromise, indicators: {} };

                            const indicationsByIndName = {};
                            indicationsByGenreContext[genreCtx].forEach(ind => {
                                if(!indicationsByIndName[ind.indicatorName]) indicationsByIndName[ind.indicatorName] = [];
                                indicationsByIndName[ind.indicatorName].push(ind);
                            });

                            for(const indicatorName of Object.keys(indicationsByIndName)){
                                receiverData.indicationsByGenre[genreCtx].indicators[indicatorName] = [];
                                indicationsByIndName[indicatorName].forEach(ind => {
                                    const animeIndicationImageUrl = ind.animeImageUrl || PLACEHOLDER_IMG_SEARCH_RESULT;
                                    const animeImagePromise = ensureImageIsAccessible(animeIndicationImageUrl, PLACEHOLDER_IMG_ERROR_40x60)
                                        .then(finalUrl => ({ ...ind, finalAnimeImageUrl: finalUrl }));
                                    allImagePromises.push(animeImagePromise);
                                    receiverData.indicationsByGenre[genreCtx].indicators[indicatorName].push({ ...ind, animeImagePromise });
                                });
                            }
                        }
                    }
                    if (hasIndicationsForThisReceiver) {
                        receiversRenderData.push(receiverData);
                    }
                }

                await Promise.all(allImagePromises.map(p => p.catch(e => e))); 

                for (const receiverData of receiversRenderData) {
                    let receiverBlockHTML = '';
                    let hasIndicationsForThisReceiverInBlock = false;

                    for (const genreCtx of Object.keys(receiverData.indicationsByGenre)) {
                         hasIndicationsForThisReceiverInBlock = true;
                        const genreIconData = await receiverData.indicationsByGenre[genreCtx].genreIconPromise;
                        const finalGenreIconUrl = genreIconData.finalUrl; 
                        const genreImgHTML = `<img src="${finalGenreIconUrl}" alt="${genreCtx}" style="width: 24px; height: 24px; object-fit: contain; margin-right: 8px; display: inline-block; vertical-align: middle; overflow: hidden; border-radius: 2px;" onerror="this.src='${PLACEHOLDER_IMG_ERROR_20x20}'">`;
                        receiverBlockHTML += `<div style="font-family: 'Inter', sans-serif; font-size: 20px; font-weight: 600; color: #818cf8; margin-top: 12px; margin-bottom: 8px; line-height: 1.3; display: flex; align-items: center; letter-spacing: normal; text-rendering: optimizeLegibility; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;">${genreImgHTML}${genreCtx || 'G√™nero Desconhecido'}</div>`;

                        for (const indicatorName of Object.keys(receiverData.indicationsByGenre[genreCtx].indicators)) {
                            receiverBlockHTML += `<div style="margin-left: 16px; margin-bottom: 8px;">
                                                    <p style="font-family: 'Inter', sans-serif; font-size: 16px; font-weight: 500; color: #94a3b8; margin-bottom: 4px; line-height: 1.4; letter-spacing: normal; text-rendering: optimizeLegibility; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;">Indicado por: ${indicatorName}</p>
                                                    <ul style="list-style: none; padding-left: 0;">`;
                            for (const indData of receiverData.indicationsByGenre[genreCtx].indicators[indicatorName]) {
                                const ind = await indData.animeImagePromise; 
                                let statusTagHTML = '';
                                const isCurrentAnimeToWatch = gameState.participants.find(p=>p.name === receiverData.name)?.animeToWatch && 
                                                              gameState.participants.find(p=>p.name === receiverData.name)?.animeToWatch.malId === ind.malId && 
                                                              gameState.participants.find(p=>p.name === receiverData.name)?.animeToWatch.indicatorId === ind.indicatorId && 
                                                              gameState.participants.find(p=>p.name === receiverData.name)?.animeToWatch.genreContext === ind.genreContext;

                                if (exportType === 'history') {
                                    if (isCurrentAnimeToWatch) statusTagHTML = `<span style="font-family: 'Inter', sans-serif; font-size: 28px; margin-left: 10px; line-height: 1; color: #3b82f6; vertical-align: middle;">üé≤</span>`; 
                                    else if (ind.status === 'watched') statusTagHTML = `<span style="font-family: 'Inter', sans-serif; font-size: 28px; margin-left: 10px; line-height: 1; color: #10b981; vertical-align: middle;">‚úÖ</span>`; 
                                    else if (gameState.gameMode === 'tradicional' && ind.status === 'pending') statusTagHTML = `<span style="font-family: 'Inter', sans-serif; font-size: 28px; margin-left: 10px; line-height: 1; color: #f59e0b; vertical-align: middle;">‚è≥</span>`; 
                                } else if (exportType === 'current' && gameState.gameMode === 'tradicional' && ind.status === 'pending') {
                                    statusTagHTML = `<span style="font-family: 'Inter', sans-serif; font-size: 28px; margin-left: 10px; line-height: 1; color: #f59e0b; vertical-align: middle;">‚è≥</span>`; 
                                }
                                receiverBlockHTML += `
                                        <li style="display: flex; align-items: center; gap: 8px; padding: 4px 0; font-size: 18px; color: #e2e8f0; line-height: 1.4; font-family: 'Inter', sans-serif; letter-spacing: normal; text-rendering: optimizeLegibility; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;">
                                            <img src="${ind.finalAnimeImageUrl}" alt="Capa de ${ind.animeTitle}" style="width: 40px; height: 60px; object-fit: cover; border-radius: 2px; flex-shrink: 0; overflow: hidden;" onerror="this.src='${PLACEHOLDER_IMG_ERROR_40x60}'">
                                            <span style="flex-grow: 1;">${ind.animeTitle}</span>
                                            ${statusTagHTML}
                                        </li>`;
                            }
                            receiverBlockHTML += `</ul></div>`;
                        }
                    }
                     if (hasIndicationsForThisReceiverInBlock) {
                          listContentHTML += `<div style="margin-bottom: 24px; padding-bottom: 16px; border-bottom: 1px dashed #475569;">
                                                  <h4 style="font-family: 'Inter', sans-serif; font-size: 24px; font-weight: 600; color: #a5b4fc; margin-bottom: 12px; line-height: 1.3; letter-spacing: normal; text-rendering: optimizeLegibility; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;">${receiverData.name}</h4>
                                                  ${receiverBlockHTML}
                                              </div>`;
                     }
                }


                if (!hasAnyIndications) {
                    listContentHTML += `<p style="font-family: 'Inter', sans-serif; font-size: 18px; text-align: center; color: #94a3b8; margin-top: 16px; line-height: 1.4; letter-spacing: normal; text-rendering: optimizeLegibility; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;">Nenhuma indica√ß√£o encontrada para os crit√©rios atuais.</p>`;
                }
                exportContentDiv.innerHTML = listContentHTML;

                void exportContentDiv.offsetHeight; 
                await new Promise(resolve => setTimeout(resolve, 1000)); 


                const canvas = await html2canvas(exportContentDiv, { 
                    backgroundColor: '#0f172a', 
                    useCORS: true, 
                    scale: 1.5, 
                    logging: true,
                    windowWidth: exportContentDiv.scrollWidth,
                    windowHeight: exportContentDiv.scrollHeight
                });
                const imageURL = canvas.toDataURL('image/png');
                const link = document.createElement('a');
                link.href = imageURL;
                const filename = exportType === 'current' ? `indicacoes_atuais_${gameState.name.replace(/\s+/g, '_') || 'bingo'}.png` : `historico_indicacoes_${gameState.name.replace(/\s+/g, '_') || 'bingo'}.png`;
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                showAlert("Lista de indica√ß√µes exportada como imagem!", "success");

            } catch (error) {
                console.error(`Erro ao exportar imagem de indica√ß√µes (${exportType}):`, error);
                showAlert("Erro ao exportar imagem de indica√ß√µes. Verifique o console.", "error");
            } finally {
                if (document.getElementById(containerId)) {
                    document.body.removeChild(document.getElementById(containerId));
                }
                if(exportButton) exportButton.disabled = false;
                customAlertDiv.classList.add('hidden'); 
            }
        }

        // Backup and Restore Functions
        function handleExportAllGamesData() {
            try {
                saveCurrentGameToAllGames(); 

                const dataStr = JSON.stringify(allGamesData, null, 2); 
                const blob = new Blob([dataStr], { type: "application/json" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                const date = new Date().toISOString().slice(0, 10); 
                a.download = `anime_bingo_dados_${date}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showAlert("Todos os dados dos bingos foram exportados!", "success");
            } catch (error) {
                console.error("Erro ao exportar dados:", error);
                showAlert("Erro ao exportar dados. Verifique o console.", "error");
            }
        }

        async function handleImportGamesData() {
            if (!importFileInput || !importFileInput.files || importFileInput.files.length === 0) {
                showAlert("Nenhum arquivo selecionado para importa√ß√£o.", "info");
                return;
            }

            const file = importFileInput.files[0];
            if (file.type !== "application/json") {
                showAlert("Por favor, selecione um arquivo .json v√°lido.", "error");
                importFileInput.value = ''; 
                return;
            }

            const reader = new FileReader();
            reader.onload = async (event) => {
                try {
                    loadAllGamesData(); 

                    const importedJson = event.target.result;
                    const importedDataContainer = JSON.parse(importedJson);

                    if (typeof importedDataContainer !== 'object' || importedDataContainer === null ||
                        typeof importedDataContainer.games !== 'object' || importedDataContainer.games === null ) {
                        showAlert("Arquivo JSON inv√°lido ou formato de dados de jogos incorreto.", "error");
                        importFileInput.value = '';
                        return;
                    }

                    let importedGamesCount = 0;
                    let overwrittenGamesCount = 0;

                    for (const gameId in importedDataContainer.games) {
                        if (Object.prototype.hasOwnProperty.call(importedDataContainer.games, gameId)) {
                            const gameFromFile = importedDataContainer.games[gameId];
                            
                            if (typeof gameFromFile !== 'object' || gameFromFile === null ||
                                !gameFromFile.hasOwnProperty('id') || !gameFromFile.hasOwnProperty('name') ||
                                !gameFromFile.hasOwnProperty('currentPhase') || !gameFromFile.hasOwnProperty('participants')) {
                                console.warn(`Jogo com ID ${gameId} no arquivo importado tem formato inv√°lido. Jogo ignorado.`);
                                continue; 
                            }

                            const sanitizedGame = {
                                ...BASE_GAME_INSTANCE_STATE,
                                ...JSON.parse(JSON.stringify(gameFromFile)), 
                                id: gameFromFile.id || generateUUID(),
                                name: gameFromFile.name || BASE_GAME_INSTANCE_STATE.name,
                                createdAt: gameFromFile.createdAt || new Date().toISOString(),
                                userId: gameFromFile.userId || generateUUID(),
                                gameMode: gameFromFile.gameMode || BASE_GAME_INSTANCE_STATE.gameMode,
                                currentPhase: Object.values(PHASES).includes(gameFromFile.currentPhase) ? gameFromFile.currentPhase : PHASES.REGISTRATION,
                                participants: (gameFromFile.participants || []).map(p_in => {
                                    const participantData = {...p_in};
                                    return {
                                        id: participantData.id || generateUUID(),
                                        name: participantData.name || "Participante Desconhecido",
                                        assignedGenre: participantData.assignedGenre || null,
                                        genreDrawNumber: participantData.genreDrawNumber || null,
                                        currentAssignedGenre: participantData.currentAssignedGenre || participantData.assignedGenre || null,
                                        genreHistory: Array.isArray(participantData.genreHistory) ? [...participantData.genreHistory] : [],
                                        animeToWatch: participantData.animeToWatch ? { ...participantData.animeToWatch } : null,
                                        receivedIndications: Array.isArray(participantData.receivedIndications) ? participantData.receivedIndications.map(ind => ({ ...ind })) : [],
                                        watchedAnimesHistory: Array.isArray(participantData.watchedAnimesHistory) ? participantData.watchedAnimesHistory.map(hist => ({ ...hist })) : []
                                    };
                                }),
                                assignedGenreNames: Array.isArray(gameFromFile.assignedGenreNames) ? [...gameFromFile.assignedGenreNames] : [],
                                clubGenre: gameFromFile.clubGenre ? {...gameFromFile.clubGenre} : null,
                                clubAnimeIndication: gameFromFile.clubAnimeIndication ? {...gameFromFile.clubAnimeIndication} : null,
                                clubIndications: Array.isArray(gameFromFile.clubIndications) ? gameFromFile.clubIndications.map(ind => ({...ind})) : []
                            };
                             if (sanitizedGame.participants.length > 0) {
                                const isValidTabId = gameFromFile.currentIndicatorTabId && sanitizedGame.participants.find(p => p.id === gameFromFile.currentIndicatorTabId);
                                sanitizedGame.currentIndicatorTabId = isValidTabId ? gameFromFile.currentIndicatorTabId : sanitizedGame.participants[0].id;
                            } else {
                                sanitizedGame.currentIndicatorTabId = null;
                            }

                            if (allGamesData.games[sanitizedGame.id]) {
                                overwrittenGamesCount++;
                            } else {
                                importedGamesCount++;
                            }
                            allGamesData.games[sanitizedGame.id] = sanitizedGame; 
                        }
                    }
                    
                    allGamesData.activeGameId = null; 
                    gameState = {}; 
                    
                    saveAllGamesData(); 
                    
                    let successMessage = "Dados importados com sucesso!";
                    if (importedGamesCount > 0) successMessage += ` ${importedGamesCount} novo(s) jogo(s) adicionado(s).`;
                    if (overwrittenGamesCount > 0) successMessage += ` ${overwrittenGamesCount} jogo(s) existente(s) atualizado(s).`;
                    showAlert(successMessage, "success", 6000);
                    
                    importFileInput.value = ''; 
                    renderApp(); 

                } catch (error) {
                    console.error("Erro ao importar dados:", error);
                    showAlert(`Erro ao ler ou processar o arquivo: ${error.message}`, "error");
                    importFileInput.value = '';
                }
            };

            reader.onerror = () => {
                showAlert("Erro ao ler o arquivo selecionado.", "error");
                importFileInput.value = '';
            };
            reader.readAsText(file);
        }

        // ===== NOVAS FUN√á√ïES E L√ìGICA PARA O MODO CLUBE =====

        function renderClubGenreSetupPhase() {
            clubGenreDrawModeContent.classList.toggle('hidden', gameState.gameMode !== 'clube_sorteado' || gameState.clubGenre);
            clubGenreChooseModeContent.classList.toggle('hidden', gameState.gameMode !== 'clube_escolhido' || gameState.clubGenre);
            
            if (gameState.clubGenre) {
                chosenClubGenreDisplay.classList.remove('hidden');
                chosenClubGenreIcon.src = gameState.clubGenre.imageUrl || PLACEHOLDER_IMG_GENRE_ICON;
                chosenClubGenreIcon.alt = gameState.clubGenre.name || '√çcone do G√™nero';
                chosenClubGenreName.textContent = gameState.clubGenre.name;
                goToClubIndicationPhaseButton.classList.remove('hidden');
            } else {
                chosenClubGenreDisplay.classList.add('hidden');
                goToClubIndicationPhaseButton.classList.add('hidden');
            }
            renderGenreGridFooter(); 
        }

        function handleDrawClubGenre() {
            if (initialGenres.length === 0) {
                showAlert("Nenhum g√™nero dispon√≠vel para sorteio.", "error");
                return;
            }
            const randomIndex = Math.floor(Math.random() * initialGenres.length);
            const chosenGenre = initialGenres[randomIndex];
            const drawnNumber = chosenGenre.numbers ? chosenGenre.numbers[Math.floor(Math.random() * chosenGenre.numbers.length)] : null; 

            gameState.clubGenre = {
                name: chosenGenre.name,
                imageUrl: chosenGenre.imageUrl,
                drawnNumber: drawnNumber 
            };
            gameState.clubIndications = []; 
            gameState.clubAnimeIndication = null;

            showGenreRevealModal("o Clube", gameState.clubGenre, true);
            renderApp();
        }

        function handleChooseClubGenre(genreName, genreImageUrl, genreNumber) {
            if (gameState.gameMode !== 'clube_escolhido' || gameState.currentPhase !== PHASES.CLUB_GENRE_SETUP) {
                return; 
            }
            gameState.clubGenre = {
                name: genreName,
                imageUrl: genreImageUrl,
                drawnNumber: genreNumber 
            };
            gameState.clubIndications = [];
            gameState.clubAnimeIndication = null;

            showAlert(`G√™nero "${genreName}" selecionado para o clube!`, "success");
            renderApp();
        }


        // DOM READY E INICIALIZA√á√ÉO
        document.addEventListener('DOMContentLoaded', () => {
            participantNameInput = document.getElementById('participantNameInput');
            addParticipantButton = document.getElementById('addParticipantButton');
            participantsListDiv = document.getElementById('participantsList');
            goToNextPhaseFromRegistrationButton = document.getElementById('goToNextPhaseFromRegistrationButton'); 
            maxParticipantsWarning = document.getElementById('maxParticipantsWarning');
            registrationPhaseSection = document.getElementById('registrationPhaseSection');
            individualDrawPhaseSection = document.getElementById('individualDrawPhaseSection');
            participantsToDrawListDiv = document.getElementById('participantsToDrawList');
            drawnParticipantsListDiv = document.getElementById('drawnParticipantsList');
            goToIndicationPhaseButton = document.getElementById('goToIndicationPhaseButton');
            indicationPhaseSection = document.getElementById('indicationPhaseSection');
            indicationTabsDiv = document.getElementById('indicationTabs');
            indicationContentDiv = document.getElementById('indicationContent');
            goToAnimeDrawPhaseButton = document.getElementById('goToAnimeDrawPhaseButton');
            animeDrawPhaseSection = document.getElementById('animeDrawPhaseSection');
            participantsToDrawAnimeListDiv = document.getElementById('participantsToDrawAnimeList');
            goToWatchLoopButton = document.getElementById('goToWatchLoopButton'); 
            watchLoopPhaseSection = document.getElementById('watchLoopPhaseSection');
            watchLoopContentIndividual = document.getElementById('watchLoopContentIndividual'); 
            allAnimesWatchedMessage = document.getElementById('allAnimesWatchedMessage');
            resetGameButton = document.getElementById('resetGameButton');
            genreGridFooterDiv = document.getElementById('genreGridFooter'); 
            userIdDisplay = document.getElementById('userIdDisplay');
            footerUserId = document.getElementById('footerUserId');
            customAlertDiv = document.getElementById('customAlert');
            alertIconSpan = document.getElementById('alertIcon');
            alertMessageContentSpan = document.getElementById('alertMessageContent');
            alertCloseButton = document.getElementById('alertCloseButton');
            alertConfirmButtonsDiv = document.getElementById('alertConfirmButtons');
            alertCancelBtn = document.getElementById('alertCancelBtn');
            alertConfirmBtn = document.getElementById('alertConfirmBtn');
            genreRevealModal = document.getElementById('genreRevealModal');
            genreRevealParticipantNameModalTitle = document.getElementById('genreRevealParticipantNameModalTitle'); 
            // genreRevealIconContainer = document.getElementById('genreRevealIconContainer'); // Vari√°vel n√£o utilizada
            genreRevealIconImg = document.getElementById('genreRevealIconImg'); 
            genreRevealNameText = document.getElementById('genreRevealNameText'); 
            genreRevealNumberText = document.getElementById('genreRevealNumberText'); 
            closeGenreRevealModalButton = document.getElementById('closeGenreRevealModalButton');
            animeRevealModal = document.getElementById('animeRevealModal');
            animeRevealParticipantName = document.getElementById('animeRevealParticipantName');
            animeRevealCover = document.getElementById('animeRevealCover');
            animeRevealTitleLink = document.getElementById('animeRevealTitleLink'); 
            animeRevealIndicator = document.getElementById('animeRevealIndicator');
            animeRevealScore = document.getElementById('animeRevealScore'); 
            closeAnimeRevealModalButton = document.getElementById('closeAnimeRevealModalButton');
            gameManagementSection = document.getElementById('gameManagementSection');
            newGameNameInput = document.getElementById('newGameNameInput');
            newGameModeSelect = document.getElementById('newGameModeSelect');
            createNewGameButton = document.getElementById('createNewGameButton');
            savedGamesListDiv = document.getElementById('savedGamesList');
            actualGameContentDiv = document.getElementById('actualGameContent');
            currentGameNameDisplay = document.getElementById('currentGameNameDisplay');
            switchGameButton = document.getElementById('switchGameButton');
            searchResultsModal = document.getElementById('searchResultsModal');
            searchResultsListDiv = document.getElementById('searchResultsList');
            closeSearchResultsModalButton = document.getElementById('closeSearchResultsModalButton');
            toggleGenreLegendButton = document.getElementById('toggleGenreLegendButton'); 
            genreLegendContainer = document.getElementById('genreLegendContainer'); 
            exportIndicationsButton = document.getElementById('exportIndicationsButton'); 
            exportFullIndicationHistoryButton = document.getElementById('exportFullIndicationHistoryButton'); 
            
            importFileInput = document.getElementById('importFileInput');
            importGamesButton = document.getElementById('importGamesButton');
            exportAllGamesButton = document.getElementById('exportAllGamesButton');

            // Elementos do Modo Clube
            clubGenreSetupPhaseSection = document.getElementById('clubGenreSetupPhaseSection');
            clubGenreDrawModeContent = document.getElementById('clubGenreDrawModeContent');
            drawClubGenreButton = document.getElementById('drawClubGenreButton');
            clubGenreChooseModeContent = document.getElementById('clubGenreChooseModeContent');
            chosenClubGenreDisplay = document.getElementById('chosenClubGenreDisplay');
            chosenClubGenreIcon = document.getElementById('chosenClubGenreIcon');
            chosenClubGenreName = document.getElementById('chosenClubGenreName');
            goToClubIndicationPhaseButton = document.getElementById('goToClubIndicationPhaseButton');
            indicationPhaseTitle = document.getElementById('indicationPhaseTitle');
            clubGenreForIndicationDisplay = document.getElementById('clubGenreForIndicationDisplay');
            clubGenreForIndicationIcon = document.getElementById('clubGenreForIndicationIcon');
            clubGenreForIndicationName = document.getElementById('clubGenreForIndicationName');
            animeDrawPhaseTitle = document.getElementById('animeDrawPhaseTitle');
            clubGenreForAnimeDrawDisplay = document.getElementById('clubGenreForAnimeDrawDisplay');
            clubGenreForAnimeDrawIcon = document.getElementById('clubGenreForAnimeDrawIcon');
            clubGenreForAnimeDrawName = document.getElementById('clubGenreForAnimeDrawName');
            drawClubAnimeButton = document.getElementById('drawClubAnimeButton');
            watchLoopPhaseTitle = document.getElementById('watchLoopPhaseTitle');
            watchLoopContentIndividual = document.getElementById('watchLoopContentIndividual');
            watchLoopContentClub = document.getElementById('watchLoopContentClub');
            clubResultGenre = document.getElementById('clubResultGenre');
            clubResultGenreIcon = document.getElementById('clubResultGenreIcon');
            clubResultGenreName = document.getElementById('clubResultGenreName');
            clubResultAnime = document.getElementById('clubResultAnime');
            clubResultAnimeCover = document.getElementById('clubResultAnimeCover');
            clubResultAnimeTitleLink = document.getElementById('clubResultAnimeTitleLink');
            clubResultAnimeIndicator = document.getElementById('clubResultAnimeIndicator');
            clubResultParticipants = document.getElementById('clubResultParticipants');
            clubResultParticipantsList = document.getElementById('clubResultParticipantsList');
            exportClubResultButton = document.getElementById('exportClubResultButton');


            if (alertCloseButton) alertCloseButton.onclick = () => { customAlertDiv.classList.add('hidden'); if (currentAlertResolve) { currentAlertResolve(false); currentAlertResolve = null; } };
            if (alertCancelBtn) alertCancelBtn.onclick = () => { customAlertDiv.classList.add('hidden'); if (currentAlertResolve) { currentAlertResolve(false); currentAlertResolve = null; } };
            if (alertConfirmBtn) alertConfirmBtn.onclick = () => { customAlertDiv.classList.add('hidden'); if (currentAlertResolve) { currentAlertResolve(true); currentAlertResolve = null; } };
            if (closeGenreRevealModalButton) closeGenreRevealModalButton.onclick = () => genreRevealModal.classList.add('hidden');
            if (closeAnimeRevealModalButton) closeAnimeRevealModalButton.onclick = () => animeRevealModal.classList.add('hidden');
            if (closeSearchResultsModalButton) closeSearchResultsModalButton.onclick = () => {searchResultsModal.classList.add('hidden'); currentSearchContext = null;};
            
            if (participantNameInput) {
                participantNameInput.addEventListener('keypress', (event) => { 
                    if (event.key === 'Enter') { event.preventDefault(); if(addParticipantButton) addParticipantButton.click(); }
                });
            }
            if(newGameNameInput) { 
                newGameNameInput.addEventListener('keypress', (event) => {
                    if (event.key === 'Enter') { event.preventDefault(); if(createNewGameButton) createNewGameButton.click(); }
                });
            }
            if (toggleGenreLegendButton) { 
                toggleGenreLegendButton.onclick = () => {
                    genreLegendContainer.classList.toggle('hidden');
                    if (!genreLegendContainer.classList.contains('hidden')) { 
                        renderGenreGridFooter();
                    }
                };
            }
            if(exportWatchListButton) exportWatchListButton.onclick = exportAnimeWatchList;
            if(exportIndicationsButton) exportIndicationsButton.onclick = () => exportIndicationsList('current');
            if(exportFullIndicationHistoryButton) exportFullIndicationHistoryButton.onclick = () => exportIndicationsList('history');
            if(exportClubResultButton) exportClubResultButton.onclick = () => { /* TODO: exportClubResultImage(); */ showAlert('Exporta√ß√£o do resultado do clube ainda n√£o implementada.', 'info');};


            if (addParticipantButton) addParticipantButton.onclick = handleAddParticipant;
            
            if(goToNextPhaseFromRegistrationButton) goToNextPhaseFromRegistrationButton.onclick = () => {
                if (gameState.gameMode === 'infinito' || gameState.gameMode === 'tradicional') {
                    gameState.currentPhase = PHASES.INDIVIDUAL_DRAW_SELECTION;
                } else if (gameState.gameMode === 'clube_sorteado' || gameState.gameMode === 'clube_escolhido') {
                    gameState.currentPhase = PHASES.CLUB_GENRE_SETUP;
                }
                renderApp();
            };
            if(goToIndicationPhaseButton) goToIndicationPhaseButton.onclick = () => { 
                gameState.participants.forEach(p => { 
                    if(!p.receivedIndications) p.receivedIndications = []; 
                }); 
                gameState.currentPhase = PHASES.INDICATION; 
                gameState.currentIndicatorTabId = gameState.participants[0]?.id || null; 
                renderApp(); 
            };
            if(goToAnimeDrawPhaseButton) goToAnimeDrawPhaseButton.onclick = () => {
                if (gameState.gameMode === 'clube_sorteado' || gameState.gameMode === 'clube_escolhido') {
                    gameState.currentPhase = PHASES.CLUB_ANIME_DRAW;
                } else {
                    gameState.currentPhase = PHASES.ANIME_DRAW_SELECTION; 
                }
                renderApp(); 
            };
            if(goToWatchLoopButton) goToWatchLoopButton.onclick = () => { 
                if (gameState.gameMode === 'clube_sorteado' || gameState.gameMode === 'clube_escolhido') {
                    gameState.currentPhase = PHASES.CLUB_RESULT_DISPLAY;
                } else {
                    gameState.currentPhase = PHASES.WATCH_LOOP; 
                }
                renderApp(); 
            };
            if(resetGameButton) resetGameButton.onclick = handleResetGame;
            if(createNewGameButton) createNewGameButton.onclick = createNewGame;
            if(switchGameButton) switchGameButton.onclick = () => {
                allGamesData.activeGameId = null; 
                gameState = {}; 
                saveAllGamesData(); 
                renderApp(); 
            };

            if (importGamesButton) importGamesButton.onclick = handleImportGamesData;
            if (exportAllGamesButton) exportAllGamesButton.onclick = handleExportAllGamesData;

            // Event listeners para modo clube
            if(drawClubGenreButton) drawClubGenreButton.onclick = handleDrawClubGenre;
            if(goToClubIndicationPhaseButton) goToClubIndicationPhaseButton.onclick = () => {
                if (!gameState.clubGenre) {
                    showAlert("Por favor, defina um g√™nero para o clube primeiro.", "error");
                    return;
                }
                gameState.currentPhase = PHASES.INDICATION; 
                gameState.currentIndicatorTabId = gameState.participants[0]?.id || null;
                renderApp();
            };
            if(drawClubAnimeButton) drawClubAnimeButton.onclick = handleDrawClubAnime;


            loadAllGamesData(); 
            renderApp(); 
            renderGenreGridFooter(); 
        });
    </script>
</body>
</html>
